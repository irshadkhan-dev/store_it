import { isPlainObject, isRedirect, isNotFound } from "@tanstack/react-router";
import invariant from "tiny-invariant";
import { eventHandler, toWebRequest, getHeaders, getResponseStatus, getEvent } from "@tanstack/start-server";
import { startSerializer } from "@tanstack/start-client";
import _serverFnManifest from "tsr:server-fn-manifest";
const dummy = 1;
const index = eventHandler(handleServerAction);
const serverFnManifest = _serverFnManifest;
async function handleServerAction(event) {
  const request = toWebRequest(event);
  const response = await handleServerRequest(request);
  Object.entries(getHeaders()).forEach(([key, value]) => {
    if (key && value && (!response.headers.has(key) || !response.headers.get(key)) && // For some reason, content-length is being set by h3, but doesn't
    // match the actual content length of the response.
    key.toLowerCase() !== "content-length") {
      response.headers.set(key, value);
    }
  });
  return response;
}
function sanitizeBase(base) {
  if (!base) {
    throw new Error(
      "ðŸš¨ process.env.TSS_SERVER_FN_BASE is required in start/server-handler/index"
    );
  }
  return base.replace(/^\/|\/$/g, "");
}
async function handleServerRequest(request, _event) {
  const method = request.method;
  const url = new URL(request.url, "http://localhost:3000");
  const regex = new RegExp(
    `${sanitizeBase(process.env.TSS_SERVER_FN_BASE)}/([^/?#]+)`
  );
  const match = url.pathname.match(regex);
  const serverFnId = match ? match[1] : null;
  const search = Object.fromEntries(url.searchParams.entries());
  if (typeof serverFnId !== "string") {
    throw new Error("Invalid server action param for serverFnId: " + serverFnId);
  }
  const serverFnInfo = serverFnManifest[serverFnId];
  if (!serverFnInfo) {
    console.log("serverFnManifest", serverFnManifest);
    throw new Error("Server function info not found for " + serverFnId);
  }
  if (process.env.NODE_ENV === "development")
    console.info(`
ServerFn Request: ${serverFnId}`);
  let fnModule;
  if (process.env.NODE_ENV === "development") {
    fnModule = await globalThis.app.getRouter("server").internals.devServer.ssrLoadModule(serverFnInfo.extractedFilename);
  } else {
    fnModule = await serverFnInfo.importer();
  }
  if (!fnModule) {
    console.log("serverFnManifest", serverFnManifest);
    throw new Error("Server function module not resolved for " + serverFnId);
  }
  const action = fnModule[serverFnInfo.functionName];
  if (!action) {
    console.log("serverFnManifest", serverFnManifest);
    console.log("fnModule", fnModule);
    throw new Error(
      `Server function module export not resolved for serverFn ID: ${serverFnId}`
    );
  }
  const formDataContentTypes = [
    "multipart/form-data",
    "application/x-www-form-urlencoded"
  ];
  const response = await (async () => {
    try {
      const arg = await (async () => {
        if (request.headers.get("Content-Type") && formDataContentTypes.some(
          (type) => {
            var _a;
            return (_a = request.headers.get("Content-Type")) == null ? void 0 : _a.includes(type);
          }
        )) {
          invariant(
            method.toLowerCase() !== "get",
            "GET requests with FormData payloads are not supported"
          );
          return await request.formData();
        }
        if (method.toLowerCase() === "get") {
          if (!search.payload) {
            return void 0;
          }
          return startSerializer.parse(search.payload);
        }
        const jsonPayloadAsString = await request.text();
        return startSerializer.parse(jsonPayloadAsString);
      })();
      const result = await action(arg);
      if (result instanceof Response) {
        return result;
      } else if (isPlainObject(result) && "result" in result && result.result instanceof Response) {
        return result.result;
      }
      if (isRedirect(result) || isNotFound(result)) {
        return redirectOrNotFoundResponse(result);
      }
      return new Response(
        result !== void 0 ? startSerializer.stringify(result) : void 0,
        {
          status: getResponseStatus(getEvent()),
          headers: {
            "Content-Type": "application/json"
          }
        }
      );
    } catch (error) {
      if (error instanceof Response) {
        return error;
      } else if (isPlainObject(error) && "result" in error && error.result instanceof Response) {
        return error.result;
      }
      if (isRedirect(error) || isNotFound(error)) {
        return redirectOrNotFoundResponse(error);
      }
      console.error("Server Fn Error!");
      console.error(error);
      console.info();
      return new Response(startSerializer.stringify(error), {
        status: 500,
        headers: {
          "Content-Type": "application/json"
        }
      });
    }
  })();
  if (process.env.NODE_ENV === "development")
    console.info(`ServerFn Response: ${response.status}`);
  if (response.headers.get("Content-Type") === "application/json") {
    const cloned = response.clone();
    const text = await cloned.text();
    const payload = text ? JSON.stringify(JSON.parse(text)) : "undefined";
    if (process.env.NODE_ENV === "development")
      console.info(
        ` - Payload: ${payload.length > 100 ? payload.substring(0, 100) + "..." : payload}`
      );
  }
  if (process.env.NODE_ENV === "development") console.info();
  return response;
}
function redirectOrNotFoundResponse(error) {
  const { headers, ...rest } = error;
  return new Response(JSON.stringify(rest), {
    status: 200,
    headers: {
      "Content-Type": "application/json",
      ...headers || {}
    }
  });
}
export {
  index as default,
  dummy
};
//# sourceMappingURL=index.js.map
