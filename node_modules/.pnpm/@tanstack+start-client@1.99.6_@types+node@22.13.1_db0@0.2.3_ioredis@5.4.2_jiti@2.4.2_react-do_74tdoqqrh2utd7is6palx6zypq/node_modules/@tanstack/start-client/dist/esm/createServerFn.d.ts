import { Constrain, Expand, ResolveValidatorInput, SerializerParse, SerializerStringify, SerializerStringifyBy, Validator } from '@tanstack/react-router';
import { AnyMiddleware, AssignAllServerContext, IntersectAllValidatorInputs, IntersectAllValidatorOutputs } from './createMiddleware.js';
export interface JsonResponse<TData> extends Response {
    json: () => Promise<TData>;
}
export type CompiledFetcherFnOptions = {
    method: Method;
    data: unknown;
    headers?: HeadersInit;
    context?: any;
};
export type Fetcher<TMiddlewares, TValidator, TResponse> = undefined extends IntersectAllValidatorInputs<TMiddlewares, TValidator> ? OptionalFetcher<TMiddlewares, TValidator, TResponse> : RequiredFetcher<TMiddlewares, TValidator, TResponse>;
export interface FetcherBase {
    url: string;
    __executeServer: (opts: {
        method: Method;
        data: unknown;
        headers?: HeadersInit;
        context?: any;
    }) => Promise<unknown>;
}
export interface OptionalFetcher<TMiddlewares, TValidator, TResponse> extends FetcherBase {
    (...args: [options?: OptionalFetcherDataOptions<TMiddlewares, TValidator>]): Promise<FetcherData<TResponse>>;
}
export interface RequiredFetcher<TMiddlewares, TValidator, TResponse> extends FetcherBase {
    (opts: RequiredFetcherDataOptions<TMiddlewares, TValidator>): Promise<FetcherData<TResponse>>;
}
export type FetcherBaseOptions = {
    headers?: HeadersInit;
};
export interface RequiredFetcherDataOptions<TMiddlewares, TValidator> extends FetcherBaseOptions {
    data: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>;
}
export interface OptionalFetcherDataOptions<TMiddlewares, TValidator> extends FetcherBaseOptions {
    data?: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>;
}
export type FetcherData<TResponse> = TResponse extends JsonResponse<any> ? SerializerParse<ReturnType<TResponse['json']>> : SerializerParse<TResponse>;
export type RscStream<T> = {
    __cacheState: T;
};
export type Method = 'GET' | 'POST';
export type ServerFn<TMethod, TMiddlewares, TValidator, TResponse> = (ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>) => Promise<SerializerStringify<TResponse>> | SerializerStringify<TResponse>;
export interface ServerFnCtx<TMethod, TMiddlewares, TValidator> {
    method: TMethod;
    data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TValidator>>;
    context: Expand<AssignAllServerContext<TMiddlewares>>;
}
export type CompiledFetcherFn<TResponse> = {
    (opts: CompiledFetcherFnOptions & ServerFnBaseOptions<Method>): Promise<TResponse>;
    url: string;
};
type ServerFnBaseOptions<TMethod extends Method = 'GET', TResponse = unknown, TMiddlewares = unknown, TInput = unknown> = {
    method: TMethod;
    validateClient?: boolean;
    middleware?: Constrain<TMiddlewares, ReadonlyArray<AnyMiddleware>>;
    validator?: ConstrainValidator<TInput>;
    extractedFn?: CompiledFetcherFn<TResponse>;
    serverFn?: ServerFn<TMethod, TMiddlewares, TInput, TResponse>;
    filename: string;
    functionId: string;
};
export type ValidatorSerializerStringify<TValidator> = Validator<SerializerStringifyBy<ResolveValidatorInput<TValidator>, Date | undefined | FormData>, any>;
export type ConstrainValidator<TValidator> = unknown extends TValidator ? TValidator : Constrain<TValidator, ValidatorSerializerStringify<TValidator>>;
export interface ServerFnMiddleware<TMethod extends Method, TValidator> {
    middleware: <const TNewMiddlewares = undefined>(middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>) => ServerFnAfterMiddleware<TMethod, TNewMiddlewares, TValidator>;
}
export interface ServerFnAfterMiddleware<TMethod extends Method, TMiddlewares, TValidator> extends ServerFnValidator<TMethod, TMiddlewares>, ServerFnHandler<TMethod, TMiddlewares, TValidator> {
}
export type ValidatorFn<TMethod extends Method, TMiddlewares> = <TValidator>(validator: ConstrainValidator<TValidator>) => ServerFnAfterValidator<TMethod, TMiddlewares, TValidator>;
export interface ServerFnValidator<TMethod extends Method, TMiddlewares> {
    validator: ValidatorFn<TMethod, TMiddlewares>;
}
export interface ServerFnAfterValidator<TMethod extends Method, TMiddlewares, TValidator> extends ServerFnMiddleware<TMethod, TValidator>, ServerFnHandler<TMethod, TMiddlewares, TValidator> {
}
export interface ServerFnHandler<TMethod extends Method, TMiddlewares, TValidator> {
    handler: <TNewResponse>(fn?: ServerFn<TMethod, TMiddlewares, TValidator, TNewResponse>) => Fetcher<TMiddlewares, TValidator, TNewResponse>;
}
export interface ServerFnBuilder<TMethod extends Method = 'GET'> extends ServerFnMiddleware<TMethod, undefined>, ServerFnValidator<TMethod, undefined>, ServerFnHandler<TMethod, undefined, undefined> {
    options: ServerFnBaseOptions<TMethod, unknown, undefined, undefined>;
}
export declare function createServerFn<TMethod extends Method, TResponse = unknown, TMiddlewares = undefined, TValidator = undefined>(options?: {
    method: TMethod;
}, __opts?: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>): ServerFnBuilder<TMethod>;
export type MiddlewareOptions = {
    method: Method;
    data: any;
    headers?: HeadersInit;
    sendContext?: any;
    context?: any;
};
export type MiddlewareResult = MiddlewareOptions & {
    result?: unknown;
    error?: unknown;
};
export type NextFn = (ctx: MiddlewareResult) => Promise<MiddlewareResult>;
export type MiddlewareFn = (ctx: MiddlewareOptions & {
    next: NextFn;
}) => Promise<MiddlewareResult>;
export {};
