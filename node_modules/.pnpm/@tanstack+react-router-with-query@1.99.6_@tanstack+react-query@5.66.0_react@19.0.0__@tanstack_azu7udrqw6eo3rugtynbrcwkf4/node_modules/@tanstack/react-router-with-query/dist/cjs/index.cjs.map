{"version":3,"file":"index.cjs","sources":["../../src/index.tsx"],"sourcesContent":["import { Fragment } from 'react'\nimport {\n  QueryClientProvider,\n  dehydrate,\n  hashKey,\n  hydrate,\n} from '@tanstack/react-query'\nimport type { AnyRouter } from '@tanstack/react-router'\nimport type {\n  QueryClient,\n  QueryObserverResult,\n  UseQueryOptions,\n} from '@tanstack/react-query'\n\nexport function routerWithQueryClient<TRouter extends AnyRouter>(\n  router: TRouter['options']['context'] extends { queryClient: QueryClient }\n    ? TRouter\n    : never,\n  queryClient: QueryClient,\n): TRouter {\n  const seenQueryKeys = new Set<string>()\n  const streamedQueryKeys = new Set<string>()\n\n  const ogClientOptions = queryClient.getDefaultOptions()\n\n  queryClient.setDefaultOptions({\n    ...ogClientOptions,\n    queries: {\n      ...ogClientOptions.queries,\n      _experimental_beforeQuery: (options: UseQueryOptions) => {\n        // Call the original beforeQuery\n        ;(ogClientOptions.queries as any)?._experimental_beforeQuery?.(options)\n\n        const hash = options.queryKeyHashFn || hashKey\n        // On the server, check if we've already seen the query before\n        if (router.isServer) {\n          if (seenQueryKeys.has(hash(options.queryKey))) {\n            return\n          }\n\n          seenQueryKeys.add(hash(options.queryKey))\n\n          // If we haven't seen the query and we have data for it,\n          // That means it's going to get dehydrated with critical\n          // data, so we can skip the injection\n          if (queryClient.getQueryData(options.queryKey) !== undefined) {\n            ;(options as any).__skipInjection = true\n            return\n          }\n        } else {\n          // On the client, pick up the deferred data from the stream\n          const dehydratedClient = router.clientSsr!.getStreamedValue<any>(\n            '__QueryClient__' + hash(options.queryKey),\n          )\n\n          // If we have data, hydrate it into the query client\n          if (dehydratedClient && !dehydratedClient.hydrated) {\n            dehydratedClient.hydrated = true\n            hydrate(queryClient, dehydratedClient)\n          }\n        }\n      },\n      _experimental_afterQuery: (\n        options: UseQueryOptions,\n        _result: QueryObserverResult,\n      ) => {\n        // On the server (if we're not skipping injection)\n        // send down the dehydrated query\n        const hash = options.queryKeyHashFn || hashKey\n        if (\n          router.isServer &&\n          !(options as any).__skipInjection &&\n          queryClient.getQueryData(options.queryKey) !== undefined &&\n          !streamedQueryKeys.has(hash(options.queryKey))\n        ) {\n          streamedQueryKeys.add(hash(options.queryKey))\n\n          router.serverSsr!.streamValue(\n            '__QueryClient__' + hash(options.queryKey),\n            dehydrate(queryClient, {\n              shouldDehydrateMutation: () => false,\n              shouldDehydrateQuery: (query) =>\n                hash(query.queryKey) === hash(options.queryKey),\n            }),\n          )\n        }\n\n        // Call the original afterQuery\n        ;(ogClientOptions.queries as any)?._experimental_afterQuery?.(\n          options,\n          _result,\n        )\n      },\n    } as any,\n  })\n\n  const ogOptions = router.options\n  router.options = {\n    ...router.options,\n    dehydrate: () => {\n      return {\n        ...ogOptions.dehydrate?.(),\n        // When critical data is dehydrated, we also dehydrate the query client\n        dehydratedQueryClient: dehydrate(queryClient),\n      }\n    },\n    hydrate: (dehydrated: any) => {\n      ogOptions.hydrate?.(dehydrated)\n      // On the client, hydrate the query client with the dehydrated data\n      hydrate(queryClient, dehydrated.dehydratedQueryClient)\n    },\n    context: {\n      ...ogOptions.context,\n      // Pass the query client to the context, so we can access it in loaders\n      queryClient,\n    },\n    // Wrap the app in a QueryClientProvider\n    Wrap: ({ children }) => {\n      const OGWrap = ogOptions.Wrap || Fragment\n      return (\n        <QueryClientProvider client={queryClient}>\n          <OGWrap>{children}</OGWrap>\n        </QueryClientProvider>\n      )\n    },\n  }\n\n  return router\n}\n"],"names":["hashKey","hydrate","dehydrate","Fragment","QueryClientProvider","jsx"],"mappings":";;;;;AAcgB,SAAA,sBACd,QAGA,aACS;AACH,QAAA,oCAAoB,IAAY;AAChC,QAAA,wCAAwB,IAAY;AAEpC,QAAA,kBAAkB,YAAY,kBAAkB;AAEtD,cAAY,kBAAkB;AAAA,IAC5B,GAAG;AAAA,IACH,SAAS;AAAA,MACP,GAAG,gBAAgB;AAAA,MACnB,2BAA2B,CAAC,YAA6B;;AAErD,oCAAgB,YAAhB,mBAAiC,8BAAjC,4BAA6D;AAEzD,cAAA,OAAO,QAAQ,kBAAkBA,WAAA;AAEvC,YAAI,OAAO,UAAU;AACnB,cAAI,cAAc,IAAI,KAAK,QAAQ,QAAQ,CAAC,GAAG;AAC7C;AAAA,UAAA;AAGF,wBAAc,IAAI,KAAK,QAAQ,QAAQ,CAAC;AAKxC,cAAI,YAAY,aAAa,QAAQ,QAAQ,MAAM,QAAW;AAC1D,oBAAgB,kBAAkB;AACpC;AAAA,UAAA;AAAA,QACF,OACK;AAEC,gBAAA,mBAAmB,OAAO,UAAW;AAAA,YACzC,oBAAoB,KAAK,QAAQ,QAAQ;AAAA,UAC3C;AAGI,cAAA,oBAAoB,CAAC,iBAAiB,UAAU;AAClD,6BAAiB,WAAW;AAC5BC,uBAAA,QAAQ,aAAa,gBAAgB;AAAA,UAAA;AAAA,QACvC;AAAA,MAEJ;AAAA,MACA,0BAA0B,CACxB,SACA,YACG;;AAGG,cAAA,OAAO,QAAQ,kBAAkBD,WAAA;AACvC,YACE,OAAO,YACP,CAAE,QAAgB,mBAClB,YAAY,aAAa,QAAQ,QAAQ,MAAM,UAC/C,CAAC,kBAAkB,IAAI,KAAK,QAAQ,QAAQ,CAAC,GAC7C;AACA,4BAAkB,IAAI,KAAK,QAAQ,QAAQ,CAAC;AAE5C,iBAAO,UAAW;AAAA,YAChB,oBAAoB,KAAK,QAAQ,QAAQ;AAAA,YACzCE,WAAAA,UAAU,aAAa;AAAA,cACrB,yBAAyB,MAAM;AAAA,cAC/B,sBAAsB,CAAC,UACrB,KAAK,MAAM,QAAQ,MAAM,KAAK,QAAQ,QAAQ;AAAA,YACjD,CAAA;AAAA,UACH;AAAA,QAAA;AAIA,oCAAgB,YAAhB,mBAAiC,6BAAjC;AAAA;AAAA,UACA;AAAA,UACA;AAAA;AAAA,MACF;AAAA,IACF;AAAA,EACF,CACD;AAED,QAAM,YAAY,OAAO;AACzB,SAAO,UAAU;AAAA,IACf,GAAG,OAAO;AAAA,IACV,WAAW,MAAM;;AACR,aAAA;AAAA,QACL,IAAG,eAAU,cAAV;AAAA;AAAA,QAEH,uBAAuBA,qBAAU,WAAW;AAAA,MAC9C;AAAA,IACF;AAAA,IACA,SAAS,CAAC,eAAoB;;AAC5B,sBAAU,YAAV,mCAAoB;AAEZD,yBAAA,aAAa,WAAW,qBAAqB;AAAA,IACvD;AAAA,IACA,SAAS;AAAA,MACP,GAAG,UAAU;AAAA;AAAA,MAEb;AAAA,IACF;AAAA;AAAA,IAEA,MAAM,CAAC,EAAE,eAAe;AAChB,YAAA,SAAS,UAAU,QAAQE,MAAA;AACjC,4CACGC,WAAAA,qBAAoB,EAAA,QAAQ,aAC3B,UAACC,2BAAAA,IAAA,QAAA,EAAQ,UAAS,EACpB,CAAA;AAAA,IAAA;AAAA,EAGN;AAEO,SAAA;AACT;;"}