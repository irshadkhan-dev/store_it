"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const reactRouter = require("@tanstack/react-router");
const headers = require("./headers.cjs");
const registerGlobalMiddleware = require("./registerGlobalMiddleware.cjs");
const serializer = require("./serializer.cjs");
function createServerFn(options, __opts) {
  const resolvedOptions = __opts || options || {};
  if (typeof resolvedOptions.method === "undefined") {
    resolvedOptions.method = "GET";
  }
  return {
    options: resolvedOptions,
    middleware: (middleware) => {
      return createServerFn(
        void 0,
        Object.assign(resolvedOptions, { middleware })
      );
    },
    validator: (validator) => {
      return createServerFn(
        void 0,
        Object.assign(resolvedOptions, { validator })
      );
    },
    handler: (...args) => {
      const [extractedFn, serverFn] = args;
      Object.assign(resolvedOptions, {
        ...extractedFn,
        extractedFn,
        serverFn
      });
      if (!extractedFn.url) {
        console.warn(extractedFn);
        reactRouter.warning(
          false,
          `createServerFn must be called with a function that has a 'url' property. Ensure that the @tanstack/start-plugin is ordered **before** the @tanstack/server-functions-plugin.`
        );
      }
      const resolvedMiddleware = [
        ...resolvedOptions.middleware || [],
        serverFnBaseToMiddleware(resolvedOptions)
      ];
      return Object.assign(
        async (opts) => {
          return executeMiddleware(resolvedMiddleware, "client", {
            ...extractedFn,
            method: resolvedOptions.method,
            data: opts == null ? void 0 : opts.data,
            headers: opts == null ? void 0 : opts.headers,
            context: {}
          }).then((d) => {
            if (d.error) throw d.error;
            return d.result;
          });
        },
        {
          // This copies over the URL, function ID and filename
          ...extractedFn,
          // The extracted function on the server-side calls
          // this function
          __executeServer: async (opts) => {
            const parsedOpts = opts instanceof FormData ? extractFormDataContext(opts) : opts;
            const result = await executeMiddleware(
              resolvedMiddleware,
              "server",
              {
                ...extractedFn,
                ...parsedOpts
              }
            ).then((d) => ({
              // Only send the result and sendContext back to the client
              result: d.result,
              error: d.error,
              context: d.sendContext
            }));
            return result;
          }
        }
      );
    }
  };
}
function extractFormDataContext(formData) {
  const serializedContext = formData.get("__TSR_CONTEXT");
  formData.delete("__TSR_CONTEXT");
  if (typeof serializedContext !== "string") {
    return {
      context: {},
      data: formData
    };
  }
  try {
    const context = serializer.startSerializer.parse(serializedContext);
    return {
      context,
      data: formData
    };
  } catch {
    return {
      data: formData
    };
  }
}
function flattenMiddlewares(middlewares) {
  const seen = /* @__PURE__ */ new Set();
  const flattened = [];
  const recurse = (middleware) => {
    middleware.forEach((m) => {
      if (m.options.middleware) {
        recurse(m.options.middleware);
      }
      if (!seen.has(m)) {
        seen.add(m);
        flattened.push(m);
      }
    });
  };
  recurse(middlewares);
  return flattened;
}
const applyMiddleware = async (middlewareFn, ctx, nextFn) => {
  return middlewareFn({
    ...ctx,
    next: async (userCtx = {}) => {
      return nextFn({
        ...ctx,
        ...userCtx,
        context: {
          ...ctx.context,
          ...userCtx.context
        },
        sendContext: {
          ...ctx.sendContext,
          ...userCtx.sendContext ?? {}
        },
        headers: headers.mergeHeaders(ctx.headers, userCtx.headers),
        result: userCtx.result !== void 0 ? userCtx.result : ctx.result,
        error: userCtx.error ?? ctx.error
      });
    }
  });
};
function execValidator(validator, input) {
  if (validator == null) return {};
  if ("~standard" in validator) {
    const result = validator["~standard"].validate(input);
    if (result instanceof Promise)
      throw new Error("Async validation not supported");
    if (result.issues)
      throw new Error(JSON.stringify(result.issues, void 0, 2));
    return result.value;
  }
  if ("parse" in validator) {
    return validator.parse(input);
  }
  if (typeof validator === "function") {
    return validator(input);
  }
  throw new Error("Invalid validator type!");
}
async function executeMiddleware(middlewares, env, opts) {
  const flattenedMiddlewares = flattenMiddlewares([
    ...registerGlobalMiddleware.globalMiddleware,
    ...middlewares
  ]);
  const next = async (ctx) => {
    const nextMiddleware = flattenedMiddlewares.shift();
    if (!nextMiddleware) {
      return ctx;
    }
    if (nextMiddleware.options.validator && (env === "client" ? nextMiddleware.options.validateClient : true)) {
      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data);
    }
    const middlewareFn = env === "client" ? nextMiddleware.options.client : nextMiddleware.options.server;
    if (middlewareFn) {
      return applyMiddleware(middlewareFn, ctx, async (newCtx) => {
        const clientAfter = nextMiddleware.options.clientAfter;
        if (env === "client" && clientAfter) {
          const result = await next(newCtx);
          return applyMiddleware(
            clientAfter,
            {
              ...newCtx,
              ...result
            },
            // Identity, because there "next" is just returning
            (d) => d
          );
        }
        return next(newCtx).catch((error) => {
          if (reactRouter.isRedirect(error) || reactRouter.isNotFound(error)) {
            return {
              ...newCtx,
              error
            };
          }
          throw error;
        });
      });
    }
    return next(ctx);
  };
  return next({
    ...opts,
    headers: opts.headers || {},
    sendContext: opts.sendContext || {},
    context: opts.context || {}
  });
}
function serverFnBaseToMiddleware(options) {
  return {
    _types: void 0,
    options: {
      validator: options.validator,
      validateClient: options.validateClient,
      client: async ({ next, sendContext, ...ctx }) => {
        var _a;
        const serverCtx = await ((_a = options.extractedFn) == null ? void 0 : _a.call(options, {
          ...ctx,
          // switch the sendContext over to context
          context: sendContext
        }));
        return next(serverCtx);
      },
      server: async ({ next, ...ctx }) => {
        var _a;
        const result = await ((_a = options.serverFn) == null ? void 0 : _a.call(options, ctx));
        return next({
          ...ctx,
          result
        });
      }
    }
  };
}
exports.createServerFn = createServerFn;
//# sourceMappingURL=createServerFn.cjs.map
