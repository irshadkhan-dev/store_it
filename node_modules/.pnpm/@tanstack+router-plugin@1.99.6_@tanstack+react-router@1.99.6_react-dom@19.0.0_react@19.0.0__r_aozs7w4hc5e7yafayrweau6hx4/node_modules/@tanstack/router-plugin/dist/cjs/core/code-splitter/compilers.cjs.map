{"version":3,"file":"compilers.cjs","sources":["../../../../src/core/code-splitter/compilers.ts"],"sourcesContent":["import * as t from '@babel/types'\nimport babel from '@babel/core'\nimport * as template from '@babel/template'\nimport { deadCodeElimination } from 'babel-dead-code-elimination'\nimport { generateFromAst, parseAst } from '@tanstack/router-utils'\nimport { splitPrefix } from '../constants'\nimport type { GeneratorResult, ParseAstOptions } from '@tanstack/router-utils'\n\nconst debug = process.env.TSR_VITE_DEBUG\n\ntype SplitModulesById = Record<\n  string,\n  { id: string; node: t.FunctionExpression }\n>\n\ninterface State {\n  filename: string\n  opts: {\n    minify: boolean\n    root: string\n  }\n  imported: Record<string, boolean>\n  refs: Set<any>\n  serverIndex: number\n  splitIndex: number\n  splitModulesById: SplitModulesById\n}\n\nfunction addSplitSearchParamToFilename(filename: string) {\n  const [bareFilename] = filename.split('?')\n  return `${bareFilename}?${splitPrefix}`\n}\n\nfunction removeSplitSearchParamFromFilename(filename: string) {\n  const [bareFilename] = filename.split('?')\n  return bareFilename!\n}\n\ntype SplitRouteIdentNodes = 'component' | 'loader'\ntype SplitNodeMeta = {\n  routeIdent: SplitRouteIdentNodes\n  splitStrategy: 'normal' | 'react-component'\n  localImporterIdent: string\n  exporterIdent: string\n  localExporterIdent: string\n}\nconst SPLIT_NOES_CONFIG = new Map<SplitRouteIdentNodes, SplitNodeMeta>([\n  [\n    'component',\n    {\n      routeIdent: 'component',\n      localImporterIdent: '$$splitComponentImporter', // const $$splitComponentImporter = () => import('...')\n      splitStrategy: 'react-component',\n      localExporterIdent: 'SplitComponent', // const SplitComponent = ...\n      exporterIdent: 'component', // export { SplitComponent as component }\n    },\n  ],\n  [\n    'loader',\n    {\n      routeIdent: 'loader',\n      localImporterIdent: '$$splitLoaderImporter', // const $$splitLoaderImporter = () => import('...')\n      splitStrategy: 'normal',\n      localExporterIdent: 'SplitLoader', // const SplitLoader = ...\n      exporterIdent: 'loader', // export { SplitLoader as loader }\n    },\n  ],\n])\nconst SPLIT_ROUTE_IDENT_NODES = [...SPLIT_NOES_CONFIG.keys()] as const\n\nexport function compileCodeSplitReferenceRoute(\n  opts: ParseAstOptions,\n): GeneratorResult {\n  const ast = parseAst(opts)\n\n  babel.traverse(ast, {\n    Program: {\n      enter(programPath, programState) {\n        const state = programState as unknown as State\n\n        // We need to extract the existing search params from the filename, if any\n        // and add the splitPrefix to them, then write them back to the filename\n        const splitUrl = addSplitSearchParamToFilename(opts.filename)\n\n        /**\n         * If the component for the route is being imported from\n         * another file, this is to track the path to that file\n         * the path itself doesn't matter, we just need to keep\n         * track of it so that we can remove it from the imports\n         * list if it's not being used like:\n         *\n         * `import '../shared/imported'`\n         */\n        let existingCompImportPath: string | null = null\n        let existingLoaderImportPath: string | null = null\n\n        programPath.traverse(\n          {\n            CallExpression: (path) => {\n              if (!t.isIdentifier(path.node.callee)) {\n                return\n              }\n\n              if (\n                !(\n                  path.node.callee.name === 'createRoute' ||\n                  path.node.callee.name === 'createFileRoute'\n                )\n              ) {\n                return\n              }\n\n              if (t.isCallExpression(path.parentPath.node)) {\n                const options = resolveIdentifier(\n                  path,\n                  path.parentPath.node.arguments[0],\n                )\n\n                const hasImportedOrDefinedIdentifier = (name: string) => {\n                  return programPath.scope.hasBinding(name)\n                }\n\n                if (t.isObjectExpression(options)) {\n                  options.properties.forEach((prop) => {\n                    if (t.isObjectProperty(prop)) {\n                      if (t.isIdentifier(prop.key)) {\n                        const key = prop.key.name\n                        // find key in nodeSplitConfig\n                        const isNodeConfigAvailable = SPLIT_NOES_CONFIG.has(\n                          key as any,\n                        )\n\n                        if (!isNodeConfigAvailable) {\n                          return\n                        }\n\n                        const splitNodeMeta = SPLIT_NOES_CONFIG.get(key as any)!\n\n                        if (splitNodeMeta.splitStrategy === 'react-component') {\n                          const value = prop.value\n\n                          let shouldSplit = true\n\n                          if (t.isIdentifier(value)) {\n                            existingCompImportPath =\n                              getImportSpecifierAndPathFromLocalName(\n                                programPath,\n                                value.name,\n                              ).path\n\n                            // exported identifiers should not be split\n                            // since they are already being imported\n                            // and need to be retained in the compiled file\n                            const isExported = hasExport(ast, value)\n                            shouldSplit = !isExported\n\n                            if (shouldSplit) {\n                              removeIdentifierLiteral(path, value)\n                            }\n                          }\n\n                          if (!shouldSplit) {\n                            return\n                          }\n\n                          // Prepend the import statement to the program along with the importer function\n                          // Check to see if lazyRouteComponent is already imported before attempting\n                          // to import it again\n\n                          if (\n                            !hasImportedOrDefinedIdentifier(\n                              'lazyRouteComponent',\n                            )\n                          ) {\n                            programPath.unshiftContainer('body', [\n                              template.statement(\n                                `import { lazyRouteComponent } from '@tanstack/react-router'`,\n                              )(),\n                            ])\n                          }\n\n                          // Check to see if the importer function is already defined\n                          // If not, define it with the dynamic import statement\n                          if (\n                            !hasImportedOrDefinedIdentifier(\n                              splitNodeMeta.localImporterIdent,\n                            )\n                          ) {\n                            programPath.unshiftContainer('body', [\n                              template.statement(\n                                `const ${splitNodeMeta.localImporterIdent} = () => import('${splitUrl}')`,\n                              )(),\n                            ])\n                          }\n\n                          // If it's a component, we need to pass the function to check the Route.ssr value\n                          if (key === 'component') {\n                            prop.value = template.expression(\n                              `lazyRouteComponent(${splitNodeMeta.localImporterIdent}, '${splitNodeMeta.exporterIdent}', () => Route.ssr)`,\n                            )()\n                          } else {\n                            prop.value = template.expression(\n                              `lazyRouteComponent(${splitNodeMeta.localImporterIdent}, '${splitNodeMeta.exporterIdent}')`,\n                            )()\n                          }\n\n                          // If the TSRDummyComponent is not defined, define it\n                          if (\n                            !hasImportedOrDefinedIdentifier('TSRDummyComponent')\n                          ) {\n                            programPath.pushContainer('body', [\n                              template.statement(\n                                `export function TSRDummyComponent() { return null }`,\n                              )(),\n                            ])\n                          }\n                        }\n\n                        if (splitNodeMeta.splitStrategy === 'normal') {\n                          const value = prop.value\n\n                          let shouldSplit = true\n\n                          if (t.isIdentifier(value)) {\n                            existingLoaderImportPath =\n                              getImportSpecifierAndPathFromLocalName(\n                                programPath,\n                                value.name,\n                              ).path\n\n                            // exported identifiers should not be split\n                            // since they are already being imported\n                            // and need to be retained in the compiled file\n                            const isExported = hasExport(ast, value)\n                            shouldSplit = !isExported\n\n                            if (shouldSplit) {\n                              removeIdentifierLiteral(path, value)\n                            }\n                          }\n\n                          if (!shouldSplit) {\n                            return\n                          }\n\n                          // Prepend the import statement to the program along with the importer function\n                          if (!hasImportedOrDefinedIdentifier('lazyFn')) {\n                            programPath.unshiftContainer(\n                              'body',\n                              template.smart(\n                                `import { lazyFn } from '@tanstack/react-router'`,\n                              )(),\n                            )\n                          }\n\n                          // Check to see if the importer function is already defined\n                          // If not, define it with the dynamic import statement\n                          if (\n                            !hasImportedOrDefinedIdentifier(\n                              splitNodeMeta.localImporterIdent,\n                            )\n                          ) {\n                            programPath.unshiftContainer('body', [\n                              template.statement(\n                                `const ${splitNodeMeta.localImporterIdent} = () => import('${splitUrl}')`,\n                              )(),\n                            ])\n                          }\n\n                          // Add the lazyFn call with the dynamic import to the prop value\n                          prop.value = template.expression(\n                            `lazyFn(${splitNodeMeta.localImporterIdent}, '${splitNodeMeta.exporterIdent}')`,\n                          )()\n                        }\n                      }\n                    }\n\n                    programPath.scope.crawl()\n                  })\n                }\n              }\n            },\n          },\n          state,\n        )\n\n        /**\n         * If the component for the route is being imported,\n         * and it's not being used, remove the import statement\n         * from the program, by checking that the import has no\n         * specifiers\n         */\n        if (\n          (existingCompImportPath as string | null) ||\n          (existingLoaderImportPath as string | null)\n        ) {\n          programPath.traverse({\n            ImportDeclaration(path) {\n              if (path.node.specifiers.length > 0) return\n              if (\n                path.node.source.value === existingCompImportPath ||\n                path.node.source.value === existingLoaderImportPath\n              ) {\n                path.remove()\n              }\n            },\n          })\n        }\n      },\n    },\n  })\n\n  deadCodeElimination(ast)\n\n  return generateFromAst(ast, {\n    sourceMaps: true,\n    sourceFileName: opts.filename,\n    filename: opts.filename,\n  })\n}\n\nexport function compileCodeSplitVirtualRoute(\n  opts: ParseAstOptions,\n): GeneratorResult {\n  const ast = parseAst(opts)\n\n  const knownExportedIdents = new Set<string>()\n\n  babel.traverse(ast, {\n    Program: {\n      enter(programPath, programState) {\n        const state = programState as unknown as State\n\n        const trackedNodesToSplitByType: Record<\n          SplitRouteIdentNodes,\n          { node: t.Node | undefined; meta: SplitNodeMeta } | undefined\n        > = {\n          component: undefined,\n          loader: undefined,\n        }\n\n        // Find the node\n        programPath.traverse(\n          {\n            CallExpression: (path) => {\n              if (!t.isIdentifier(path.node.callee)) {\n                return\n              }\n\n              if (\n                !(\n                  path.node.callee.name === 'createRoute' ||\n                  path.node.callee.name === 'createFileRoute'\n                )\n              ) {\n                return\n              }\n\n              if (t.isCallExpression(path.parentPath.node)) {\n                const options = resolveIdentifier(\n                  path,\n                  path.parentPath.node.arguments[0],\n                )\n\n                if (t.isObjectExpression(options)) {\n                  options.properties.forEach((prop) => {\n                    if (t.isObjectProperty(prop)) {\n                      SPLIT_ROUTE_IDENT_NODES.forEach((splitType) => {\n                        if (\n                          !t.isIdentifier(prop.key) ||\n                          prop.key.name !== splitType\n                        ) {\n                          return\n                        }\n\n                        const value = prop.value\n\n                        let isExported = false\n                        if (t.isIdentifier(value)) {\n                          isExported = hasExport(ast, value)\n                          if (isExported) {\n                            knownExportedIdents.add(value.name)\n                          }\n                        }\n\n                        // If the node is exported, we need to remove\n                        // the export from the split file\n                        if (isExported && t.isIdentifier(value)) {\n                          removeExports(ast, value)\n                        } else {\n                          const meta = SPLIT_NOES_CONFIG.get(splitType)!\n                          trackedNodesToSplitByType[splitType] = {\n                            node: prop.value,\n                            meta,\n                          }\n                        }\n                      })\n                    }\n                  })\n\n                  // Remove all of the options\n                  options.properties = []\n                }\n              }\n            },\n          },\n          state,\n        )\n\n        SPLIT_ROUTE_IDENT_NODES.forEach((SPLIT_TYPE) => {\n          const splitKey = trackedNodesToSplitByType[SPLIT_TYPE]\n\n          if (!splitKey) {\n            return\n          }\n\n          let splitNode = splitKey.node\n          const splitMeta = splitKey.meta\n\n          while (t.isIdentifier(splitNode)) {\n            const binding = programPath.scope.getBinding(splitNode.name)\n            splitNode = binding?.path.node\n          }\n\n          // Add the node to the program\n          if (splitNode) {\n            if (t.isFunctionDeclaration(splitNode)) {\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitMeta.localExporterIdent),\n                    t.functionExpression(\n                      splitNode.id || null, // Anonymize the function expression\n                      splitNode.params,\n                      splitNode.body,\n                      splitNode.generator,\n                      splitNode.async,\n                    ),\n                  ),\n                ]),\n              )\n            } else if (\n              t.isFunctionExpression(splitNode) ||\n              t.isArrowFunctionExpression(splitNode)\n            ) {\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitMeta.localExporterIdent),\n                    splitNode as any,\n                  ),\n                ]),\n              )\n            } else if (\n              t.isImportSpecifier(splitNode) ||\n              t.isImportDefaultSpecifier(splitNode)\n            ) {\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitMeta.localExporterIdent),\n                    splitNode.local,\n                  ),\n                ]),\n              )\n            } else if (t.isVariableDeclarator(splitNode)) {\n              programPath.pushContainer(\n                'body',\n                t.variableDeclaration('const', [\n                  t.variableDeclarator(\n                    t.identifier(splitMeta.localExporterIdent),\n                    splitNode.init,\n                  ),\n                ]),\n              )\n            } else if (t.isCallExpression(splitNode)) {\n              const outputSplitNodeCode = generateFromAst(splitNode).code\n              const splitNodeAst = babel.parse(outputSplitNodeCode)\n\n              if (!splitNodeAst) {\n                throw new Error(\n                  `Failed to parse the generated code for \"${SPLIT_TYPE}\" in the node type \"${splitNode.type}\"`,\n                )\n              }\n\n              const statement = splitNodeAst.program.body[0]\n\n              if (!statement) {\n                throw new Error(\n                  `Failed to parse the generated code for \"${SPLIT_TYPE}\" in the node type \"${splitNode.type}\" as no statement was found in the program body`,\n                )\n              }\n\n              if (t.isExpressionStatement(statement)) {\n                const expression = statement.expression\n                programPath.pushContainer(\n                  'body',\n                  t.variableDeclaration('const', [\n                    t.variableDeclarator(\n                      t.identifier(splitMeta.localExporterIdent),\n                      expression,\n                    ),\n                  ]),\n                )\n              } else {\n                throw new Error(\n                  `Unexpected expression type encounter for \"${SPLIT_TYPE}\" in the node type \"${splitNode.type}\"`,\n                )\n              }\n            } else {\n              console.info('Unexpected splitNode type:', splitNode)\n              throw new Error(`Unexpected splitNode type ☝️: ${splitNode.type}`)\n            }\n          }\n\n          // If the splitNode exists at the top of the program\n          // then we need to remove that copy\n          programPath.node.body = programPath.node.body.filter((node) => {\n            return node !== splitNode\n          })\n\n          // Export the node\n          programPath.pushContainer('body', [\n            t.exportNamedDeclaration(null, [\n              t.exportSpecifier(\n                t.identifier(splitMeta.localExporterIdent), // local variable name\n                t.identifier(splitMeta.exporterIdent), // as what name it should be exported as\n              ),\n            ]),\n          ])\n        })\n\n        // convert exports to imports from the original file\n        programPath.traverse({\n          ExportNamedDeclaration(path) {\n            // e.g. export const x = 1 or export { x }\n            // becomes\n            // import { x } from '${opts.id}'\n\n            if (path.node.declaration) {\n              if (t.isVariableDeclaration(path.node.declaration)) {\n                path.replaceWith(\n                  t.importDeclaration(\n                    path.node.declaration.declarations.map((decl) =>\n                      t.importSpecifier(\n                        t.identifier((decl.id as any).name),\n                        t.identifier((decl.id as any).name),\n                      ),\n                    ),\n                    t.stringLiteral(\n                      removeSplitSearchParamFromFilename(opts.filename),\n                    ),\n                  ),\n                )\n              }\n            }\n          },\n        })\n      },\n    },\n  })\n\n  deadCodeElimination(ast)\n\n  // if there are exported identifiers, then we need to add a warning\n  // to the file to let the user know that the exported identifiers\n  // will not in the split file but in the original file, therefore\n  // increasing the bundle size\n  if (knownExportedIdents.size > 0) {\n    const list = Array.from(knownExportedIdents).reduce((str, ident) => {\n      str += `\\n- ${ident}`\n      return str\n    }, '')\n\n    const warningMessage = `These exports from \"${opts.filename.replace('?' + splitPrefix, '')}\" are not being code-split and will increase your bundle size: ${list}\\nThese should either have their export statements removed or be imported from another file that is not a route.`\n    console.warn(warningMessage)\n\n    // append this warning to the file using a template\n    if (process.env.NODE_ENV !== 'production') {\n      const warningTemplate = template.statement(\n        `console.warn(${JSON.stringify(warningMessage)})`,\n      )()\n      ast.program.body.unshift(warningTemplate)\n    }\n  }\n\n  return generateFromAst(ast, {\n    sourceMaps: true,\n    sourceFileName: opts.filename,\n    filename: opts.filename,\n  })\n}\n\nfunction getImportSpecifierAndPathFromLocalName(\n  programPath: babel.NodePath<t.Program>,\n  name: string,\n): {\n  specifier:\n    | t.ImportSpecifier\n    | t.ImportDefaultSpecifier\n    | t.ImportNamespaceSpecifier\n    | null\n  path: string | null\n} {\n  let specifier:\n    | t.ImportSpecifier\n    | t.ImportDefaultSpecifier\n    | t.ImportNamespaceSpecifier\n    | null = null\n  let path: string | null = null\n\n  programPath.traverse({\n    ImportDeclaration(importPath) {\n      const found = importPath.node.specifiers.find(\n        (targetSpecifier) => targetSpecifier.local.name === name,\n      )\n      if (found) {\n        specifier = found\n        path = importPath.node.source.value\n      }\n    },\n  })\n\n  return { specifier, path }\n}\n\n// Reusable function to get literal value or resolve variable to literal\nfunction resolveIdentifier(path: any, node: any) {\n  if (t.isIdentifier(node)) {\n    const binding = path.scope.getBinding(node.name)\n    if (\n      binding\n      // && binding.kind === 'const'\n    ) {\n      const declarator = binding.path.node\n      if (t.isObjectExpression(declarator.init)) {\n        return declarator.init\n      } else if (t.isFunctionDeclaration(declarator.init)) {\n        return declarator.init\n      }\n    }\n    return undefined\n  }\n\n  return node\n}\n\nfunction removeIdentifierLiteral(path: any, node: any) {\n  if (t.isIdentifier(node)) {\n    const binding = path.scope.getBinding(node.name)\n    if (binding) {\n      binding.path.remove()\n    }\n  }\n}\n\nfunction hasExport(ast: t.File, node: t.Identifier): boolean {\n  let found = false\n\n  babel.traverse(ast, {\n    ExportNamedDeclaration(path) {\n      if (path.node.declaration) {\n        // declared as `const loaderFn = () => {}`\n        if (t.isVariableDeclaration(path.node.declaration)) {\n          path.node.declaration.declarations.forEach((decl) => {\n            if (t.isVariableDeclarator(decl)) {\n              if (t.isIdentifier(decl.id)) {\n                if (decl.id.name === node.name) {\n                  found = true\n                }\n              }\n            }\n          })\n        }\n\n        // declared as `function loaderFn() {}`\n        if (t.isFunctionDeclaration(path.node.declaration)) {\n          if (t.isIdentifier(path.node.declaration.id)) {\n            if (path.node.declaration.id.name === node.name) {\n              found = true\n            }\n          }\n        }\n      }\n    },\n    ExportDefaultDeclaration(path) {\n      if (t.isIdentifier(path.node.declaration)) {\n        if (path.node.declaration.name === node.name) {\n          found = true\n        }\n      }\n    },\n  })\n\n  return found\n}\n\nfunction removeExports(ast: t.File, node: t.Identifier): boolean {\n  let removed = false\n\n  babel.traverse(ast, {\n    ExportNamedDeclaration(path) {\n      if (path.node.declaration) {\n        // declared as `const loaderFn = () => {}`\n        if (t.isVariableDeclaration(path.node.declaration)) {\n          path.node.declaration.declarations.forEach((decl) => {\n            if (t.isVariableDeclarator(decl)) {\n              if (t.isIdentifier(decl.id)) {\n                if (decl.id.name === node.name) {\n                  path.remove()\n                  removed = true\n                }\n              }\n            }\n          })\n        } else if (t.isFunctionDeclaration(path.node.declaration)) {\n          if (t.isIdentifier(path.node.declaration.id)) {\n            if (path.node.declaration.id.name === node.name) {\n              path.remove()\n              removed = true\n            }\n          }\n        }\n      }\n    },\n    ExportDefaultDeclaration(path) {\n      if (t.isIdentifier(path.node.declaration)) {\n        if (path.node.declaration.name === node.name) {\n          path.remove()\n          removed = true\n        }\n      }\n    },\n  })\n\n  return removed\n}\n"],"names":["splitPrefix","parseAst","t","template","deadCodeElimination","generateFromAst"],"mappings":"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"}