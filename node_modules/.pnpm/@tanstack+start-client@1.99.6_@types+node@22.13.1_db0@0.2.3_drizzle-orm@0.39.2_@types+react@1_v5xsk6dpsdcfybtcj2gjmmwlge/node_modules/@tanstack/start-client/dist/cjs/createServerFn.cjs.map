{"version":3,"file":"createServerFn.cjs","sources":["../../src/createServerFn.ts"],"sourcesContent":["import { isNotFound, isRedirect, warning } from '@tanstack/react-router'\nimport { mergeHeaders } from './headers'\nimport { globalMiddleware } from './registerGlobalMiddleware'\nimport { startSerializer } from './serializer'\nimport type {\n  AnyValidator,\n  Constrain,\n  Expand,\n  ResolveValidatorInput,\n  SerializerParse,\n  SerializerStringify,\n  SerializerStringifyBy,\n  Validator,\n} from '@tanstack/react-router'\nimport type {\n  AnyMiddleware,\n  AssignAllServerContext,\n  IntersectAllValidatorInputs,\n  IntersectAllValidatorOutputs,\n  MiddlewareClientFnResult,\n  MiddlewareServerFnResult,\n} from './createMiddleware'\n\nexport interface JsonResponse<TData> extends Response {\n  json: () => Promise<TData>\n}\n\nexport type CompiledFetcherFnOptions = {\n  method: Method\n  data: unknown\n  headers?: HeadersInit\n  context?: any\n}\n\nexport type Fetcher<TMiddlewares, TValidator, TResponse> =\n  undefined extends IntersectAllValidatorInputs<TMiddlewares, TValidator>\n    ? OptionalFetcher<TMiddlewares, TValidator, TResponse>\n    : RequiredFetcher<TMiddlewares, TValidator, TResponse>\n\nexport interface FetcherBase {\n  url: string\n  __executeServer: (opts: {\n    method: Method\n    data: unknown\n    headers?: HeadersInit\n    context?: any\n  }) => Promise<unknown>\n}\n\nexport interface OptionalFetcher<TMiddlewares, TValidator, TResponse>\n  extends FetcherBase {\n  (\n    ...args: [options?: OptionalFetcherDataOptions<TMiddlewares, TValidator>]\n  ): Promise<FetcherData<TResponse>>\n}\n\nexport interface RequiredFetcher<TMiddlewares, TValidator, TResponse>\n  extends FetcherBase {\n  (\n    opts: RequiredFetcherDataOptions<TMiddlewares, TValidator>,\n  ): Promise<FetcherData<TResponse>>\n}\n\nexport type FetcherBaseOptions = {\n  headers?: HeadersInit\n}\n\nexport interface RequiredFetcherDataOptions<TMiddlewares, TValidator>\n  extends FetcherBaseOptions {\n  data: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n}\n\nexport interface OptionalFetcherDataOptions<TMiddlewares, TValidator>\n  extends FetcherBaseOptions {\n  data?: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n}\n\nexport type FetcherData<TResponse> =\n  TResponse extends JsonResponse<any>\n    ? SerializerParse<ReturnType<TResponse['json']>>\n    : SerializerParse<TResponse>\n\nexport type RscStream<T> = {\n  __cacheState: T\n}\n\nexport type Method = 'GET' | 'POST'\n\nexport type ServerFn<TMethod, TMiddlewares, TValidator, TResponse> = (\n  ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>,\n) => Promise<SerializerStringify<TResponse>> | SerializerStringify<TResponse>\n\nexport interface ServerFnCtx<TMethod, TMiddlewares, TValidator> {\n  method: TMethod\n  data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TValidator>>\n  context: Expand<AssignAllServerContext<TMiddlewares>>\n}\n\nexport type CompiledFetcherFn<TResponse> = {\n  (\n    opts: CompiledFetcherFnOptions & ServerFnBaseOptions<Method>,\n  ): Promise<TResponse>\n  url: string\n}\n\ntype ServerFnBaseOptions<\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TInput = unknown,\n> = {\n  method: TMethod\n  validateClient?: boolean\n  middleware?: Constrain<TMiddlewares, ReadonlyArray<AnyMiddleware>>\n  validator?: ConstrainValidator<TInput>\n  extractedFn?: CompiledFetcherFn<TResponse>\n  serverFn?: ServerFn<TMethod, TMiddlewares, TInput, TResponse>\n  filename: string\n  functionId: string\n}\n\nexport type ValidatorSerializerStringify<TValidator> = Validator<\n  SerializerStringifyBy<\n    ResolveValidatorInput<TValidator>,\n    Date | undefined | FormData\n  >,\n  any\n>\n\nexport type ConstrainValidator<TValidator> = unknown extends TValidator\n  ? TValidator\n  : Constrain<TValidator, ValidatorSerializerStringify<TValidator>>\n\nexport interface ServerFnMiddleware<TMethod extends Method, TValidator> {\n  middleware: <const TNewMiddlewares = undefined>(\n    middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>,\n  ) => ServerFnAfterMiddleware<TMethod, TNewMiddlewares, TValidator>\n}\n\nexport interface ServerFnAfterMiddleware<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnValidator<TMethod, TMiddlewares>,\n    ServerFnHandler<TMethod, TMiddlewares, TValidator> {}\n\nexport type ValidatorFn<TMethod extends Method, TMiddlewares> = <TValidator>(\n  validator: ConstrainValidator<TValidator>,\n) => ServerFnAfterValidator<TMethod, TMiddlewares, TValidator>\n\nexport interface ServerFnValidator<TMethod extends Method, TMiddlewares> {\n  validator: ValidatorFn<TMethod, TMiddlewares>\n}\n\nexport interface ServerFnAfterValidator<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnMiddleware<TMethod, TValidator>,\n    ServerFnHandler<TMethod, TMiddlewares, TValidator> {}\n\nexport interface ServerFnHandler<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> {\n  handler: <TNewResponse>(\n    fn?: ServerFn<TMethod, TMiddlewares, TValidator, TNewResponse>,\n  ) => Fetcher<TMiddlewares, TValidator, TNewResponse>\n}\n\nexport interface ServerFnBuilder<TMethod extends Method = 'GET'>\n  extends ServerFnMiddleware<TMethod, undefined>,\n    ServerFnValidator<TMethod, undefined>,\n    ServerFnHandler<TMethod, undefined, undefined> {\n  options: ServerFnBaseOptions<TMethod, unknown, undefined, undefined>\n}\n\nexport function createServerFn<\n  TMethod extends Method,\n  TResponse = unknown,\n  TMiddlewares = undefined,\n  TValidator = undefined,\n>(\n  options?: {\n    method: TMethod\n  },\n  __opts?: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>,\n): ServerFnBuilder<TMethod> {\n  const resolvedOptions = (__opts || options || {}) as ServerFnBaseOptions<\n    TMethod,\n    TResponse,\n    TMiddlewares,\n    TValidator\n  >\n\n  if (typeof resolvedOptions.method === 'undefined') {\n    resolvedOptions.method = 'GET' as TMethod\n  }\n\n  return {\n    options: resolvedOptions as any,\n    middleware: (middleware) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { middleware }),\n      ) as any\n    },\n    validator: (validator) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { validator }),\n      ) as any\n    },\n    handler: (...args) => {\n      // This function signature changes due to AST transformations\n      // in the babel plugin. We need to cast it to the correct\n      // function signature post-transformation\n      const [extractedFn, serverFn] = args as unknown as [\n        CompiledFetcherFn<TResponse>,\n        ServerFn<TMethod, TMiddlewares, TValidator, TResponse>,\n      ]\n\n      // Keep the original function around so we can use it\n      // in the server environment\n      Object.assign(resolvedOptions, {\n        ...extractedFn,\n        extractedFn,\n        serverFn,\n      })\n\n      if (!extractedFn.url) {\n        console.warn(extractedFn)\n        warning(\n          false,\n          `createServerFn must be called with a function that has a 'url' property. Ensure that the @tanstack/start-plugin is ordered **before** the @tanstack/server-functions-plugin.`,\n        )\n      }\n\n      const resolvedMiddleware = [\n        ...(resolvedOptions.middleware || []),\n        serverFnBaseToMiddleware(resolvedOptions),\n      ]\n\n      // We want to make sure the new function has the same\n      // properties as the original function\n      return Object.assign(\n        async (opts?: CompiledFetcherFnOptions) => {\n          // Start by executing the client-side middleware chain\n          return executeMiddleware(resolvedMiddleware, 'client', {\n            ...extractedFn,\n            method: resolvedOptions.method,\n            data: opts?.data as any,\n            headers: opts?.headers,\n            context: {},\n          }).then((d) => {\n            if (d.error) throw d.error\n            return d.result\n          })\n        },\n        {\n          // This copies over the URL, function ID and filename\n          ...extractedFn,\n          // The extracted function on the server-side calls\n          // this function\n          __executeServer: async (opts: any) => {\n            const parsedOpts =\n              opts instanceof FormData ? extractFormDataContext(opts) : opts\n\n            const result = await executeMiddleware(\n              resolvedMiddleware,\n              'server',\n              {\n                ...extractedFn,\n                ...parsedOpts,\n              },\n            ).then((d) => ({\n              // Only send the result and sendContext back to the client\n              result: d.result,\n              error: d.error,\n              context: d.sendContext,\n            }))\n\n            return result\n          },\n        },\n      ) as any\n    },\n  }\n}\n\nfunction extractFormDataContext(formData: FormData) {\n  const serializedContext = formData.get('__TSR_CONTEXT')\n  formData.delete('__TSR_CONTEXT')\n\n  if (typeof serializedContext !== 'string') {\n    return {\n      context: {},\n      data: formData,\n    }\n  }\n\n  try {\n    const context = startSerializer.parse(serializedContext)\n    return {\n      context,\n      data: formData,\n    }\n  } catch {\n    return {\n      data: formData,\n    }\n  }\n}\n\nfunction flattenMiddlewares(\n  middlewares: Array<AnyMiddleware>,\n): Array<AnyMiddleware> {\n  const seen = new Set<AnyMiddleware>()\n  const flattened: Array<AnyMiddleware> = []\n\n  const recurse = (middleware: Array<AnyMiddleware>) => {\n    middleware.forEach((m) => {\n      if (m.options.middleware) {\n        recurse(m.options.middleware)\n      }\n\n      if (!seen.has(m)) {\n        seen.add(m)\n        flattened.push(m)\n      }\n    })\n  }\n\n  recurse(middlewares)\n\n  return flattened\n}\n\nexport type MiddlewareOptions = {\n  method: Method\n  data: any\n  headers?: HeadersInit\n  sendContext?: any\n  context?: any\n}\n\nexport type MiddlewareResult = MiddlewareOptions & {\n  result?: unknown\n  error?: unknown\n}\n\nexport type NextFn = (ctx: MiddlewareResult) => Promise<MiddlewareResult>\n\nexport type MiddlewareFn = (\n  ctx: MiddlewareOptions & {\n    next: NextFn\n  },\n) => Promise<MiddlewareResult>\n\nconst applyMiddleware = async (\n  middlewareFn: MiddlewareFn,\n  ctx: MiddlewareOptions,\n  nextFn: NextFn,\n) => {\n  return middlewareFn({\n    ...ctx,\n    next: (async (userCtx: MiddlewareResult | undefined = {} as any) => {\n      // Return the next middleware\n      return nextFn({\n        ...ctx,\n        ...userCtx,\n        context: {\n          ...ctx.context,\n          ...userCtx.context,\n        },\n        sendContext: {\n          ...ctx.sendContext,\n          ...(userCtx.sendContext ?? {}),\n        },\n        headers: mergeHeaders(ctx.headers, userCtx.headers),\n        result:\n          userCtx.result !== undefined ? userCtx.result : (ctx as any).result,\n        error: userCtx.error ?? (ctx as any).error,\n      })\n    }) as any,\n  })\n}\n\nfunction execValidator(validator: AnyValidator, input: unknown): unknown {\n  if (validator == null) return {}\n\n  if ('~standard' in validator) {\n    const result = validator['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new Error('Async validation not supported')\n\n    if (result.issues)\n      throw new Error(JSON.stringify(result.issues, undefined, 2))\n\n    return result.value\n  }\n\n  if ('parse' in validator) {\n    return validator.parse(input)\n  }\n\n  if (typeof validator === 'function') {\n    return validator(input)\n  }\n\n  throw new Error('Invalid validator type!')\n}\n\nasync function executeMiddleware(\n  middlewares: Array<AnyMiddleware>,\n  env: 'client' | 'server',\n  opts: MiddlewareOptions,\n): Promise<MiddlewareResult> {\n  const flattenedMiddlewares = flattenMiddlewares([\n    ...globalMiddleware,\n    ...middlewares,\n  ])\n\n  const next: NextFn = async (ctx) => {\n    // Get the next middleware\n    const nextMiddleware = flattenedMiddlewares.shift()\n\n    // If there are no more middlewares, return the context\n    if (!nextMiddleware) {\n      return ctx\n    }\n\n    if (\n      nextMiddleware.options.validator &&\n      (env === 'client' ? nextMiddleware.options.validateClient : true)\n    ) {\n      // Execute the middleware's input function\n      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data)\n    }\n\n    const middlewareFn = (\n      env === 'client'\n        ? nextMiddleware.options.client\n        : nextMiddleware.options.server\n    ) as MiddlewareFn | undefined\n\n    if (middlewareFn) {\n      // Execute the middleware\n      return applyMiddleware(middlewareFn, ctx, async (newCtx) => {\n        // If there is a clientAfter function and we are on the client\n        const clientAfter = nextMiddleware.options.clientAfter as\n          | MiddlewareFn\n          | undefined\n\n        if (env === 'client' && clientAfter) {\n          // We need to await the next middleware and get the result\n          const result = await next(newCtx)\n\n          // Then we can execute the clientAfter function\n          return applyMiddleware(\n            clientAfter,\n            {\n              ...newCtx,\n              ...result,\n            },\n            // Identity, because there \"next\" is just returning\n            (d: any) => d,\n          )\n        }\n\n        return next(newCtx).catch((error) => {\n          if (isRedirect(error) || isNotFound(error)) {\n            return {\n              ...newCtx,\n              error,\n            }\n          }\n\n          throw error\n        })\n      })\n    }\n\n    return next(ctx)\n  }\n\n  // Start the middleware chain\n  return next({\n    ...opts,\n    headers: opts.headers || {},\n    sendContext: opts.sendContext || {},\n    context: opts.context || {},\n  })\n}\n\nfunction serverFnBaseToMiddleware(\n  options: ServerFnBaseOptions<any, any, any, any>,\n): AnyMiddleware {\n  return {\n    _types: undefined!,\n    options: {\n      validator: options.validator,\n      validateClient: options.validateClient,\n      client: async ({ next, sendContext, ...ctx }) => {\n        // Execute the extracted function\n        // but not before serializing the context\n        const serverCtx = await options.extractedFn?.({\n          ...ctx,\n          // switch the sendContext over to context\n          context: sendContext,\n        })\n\n        return next(serverCtx) as unknown as MiddlewareClientFnResult<any, any>\n      },\n      server: async ({ next, ...ctx }) => {\n        // Execute the server function\n        const result = await options.serverFn?.(ctx)\n\n        return next({\n          ...ctx,\n          result,\n        } as any) as unknown as MiddlewareServerFnResult<any, any>\n      },\n    },\n  }\n}\n"],"names":["warning","startSerializer","mergeHeaders","globalMiddleware","isRedirect","isNotFound"],"mappings":"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"}