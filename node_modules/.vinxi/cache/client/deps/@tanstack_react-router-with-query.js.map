{
  "version": 3,
  "sources": ["../../../../.pnpm/@tanstack+react-router-with-query@1.99.6_@tanstack+react-query@5.66.0_react@19.0.0__@tanstack_azu7udrqw6eo3rugtynbrcwkf4/node_modules/@tanstack/react-router-with-query/src/index.tsx"],
  "sourcesContent": ["import { Fragment } from 'react'\nimport {\n  QueryClientProvider,\n  dehydrate,\n  hashKey,\n  hydrate,\n} from '@tanstack/react-query'\nimport type { AnyRouter } from '@tanstack/react-router'\nimport type {\n  QueryClient,\n  QueryObserverResult,\n  UseQueryOptions,\n} from '@tanstack/react-query'\n\nexport function routerWithQueryClient<TRouter extends AnyRouter>(\n  router: TRouter['options']['context'] extends { queryClient: QueryClient }\n    ? TRouter\n    : never,\n  queryClient: QueryClient,\n): TRouter {\n  const seenQueryKeys = new Set<string>()\n  const streamedQueryKeys = new Set<string>()\n\n  const ogClientOptions = queryClient.getDefaultOptions()\n\n  queryClient.setDefaultOptions({\n    ...ogClientOptions,\n    queries: {\n      ...ogClientOptions.queries,\n      _experimental_beforeQuery: (options: UseQueryOptions) => {\n        // Call the original beforeQuery\n        ;(ogClientOptions.queries as any)?._experimental_beforeQuery?.(options)\n\n        const hash = options.queryKeyHashFn || hashKey\n        // On the server, check if we've already seen the query before\n        if (router.isServer) {\n          if (seenQueryKeys.has(hash(options.queryKey))) {\n            return\n          }\n\n          seenQueryKeys.add(hash(options.queryKey))\n\n          // If we haven't seen the query and we have data for it,\n          // That means it's going to get dehydrated with critical\n          // data, so we can skip the injection\n          if (queryClient.getQueryData(options.queryKey) !== undefined) {\n            ;(options as any).__skipInjection = true\n            return\n          }\n        } else {\n          // On the client, pick up the deferred data from the stream\n          const dehydratedClient = router.clientSsr!.getStreamedValue<any>(\n            '__QueryClient__' + hash(options.queryKey),\n          )\n\n          // If we have data, hydrate it into the query client\n          if (dehydratedClient && !dehydratedClient.hydrated) {\n            dehydratedClient.hydrated = true\n            hydrate(queryClient, dehydratedClient)\n          }\n        }\n      },\n      _experimental_afterQuery: (\n        options: UseQueryOptions,\n        _result: QueryObserverResult,\n      ) => {\n        // On the server (if we're not skipping injection)\n        // send down the dehydrated query\n        const hash = options.queryKeyHashFn || hashKey\n        if (\n          router.isServer &&\n          !(options as any).__skipInjection &&\n          queryClient.getQueryData(options.queryKey) !== undefined &&\n          !streamedQueryKeys.has(hash(options.queryKey))\n        ) {\n          streamedQueryKeys.add(hash(options.queryKey))\n\n          router.serverSsr!.streamValue(\n            '__QueryClient__' + hash(options.queryKey),\n            dehydrate(queryClient, {\n              shouldDehydrateMutation: () => false,\n              shouldDehydrateQuery: (query) =>\n                hash(query.queryKey) === hash(options.queryKey),\n            }),\n          )\n        }\n\n        // Call the original afterQuery\n        ;(ogClientOptions.queries as any)?._experimental_afterQuery?.(\n          options,\n          _result,\n        )\n      },\n    } as any,\n  })\n\n  const ogOptions = router.options\n  router.options = {\n    ...router.options,\n    dehydrate: () => {\n      return {\n        ...ogOptions.dehydrate?.(),\n        // When critical data is dehydrated, we also dehydrate the query client\n        dehydratedQueryClient: dehydrate(queryClient),\n      }\n    },\n    hydrate: (dehydrated: any) => {\n      ogOptions.hydrate?.(dehydrated)\n      // On the client, hydrate the query client with the dehydrated data\n      hydrate(queryClient, dehydrated.dehydratedQueryClient)\n    },\n    context: {\n      ...ogOptions.context,\n      // Pass the query client to the context, so we can access it in loaders\n      queryClient,\n    },\n    // Wrap the app in a QueryClientProvider\n    Wrap: ({ children }) => {\n      const OGWrap = ogOptions.Wrap || Fragment\n      return (\n        <QueryClientProvider client={queryClient}>\n          <OGWrap>{children}</OGWrap>\n        </QueryClientProvider>\n      )\n    },\n  }\n\n  return router\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAcgB,SAAA,sBACd,QAGA,aACS;AACH,QAAA,gBAAA,oBAAoB,IAAY;AAChC,QAAA,oBAAA,oBAAwB,IAAY;AAEpC,QAAA,kBAAkB,YAAY,kBAAkB;AAEtD,cAAY,kBAAkB;IAC5B,GAAG;IACH,SAAS;MACP,GAAG,gBAAgB;MACnB,2BAA2B,CAAC,YAA6B;;AAErD,SAAA,MAAA,KAAA,gBAAgB,YAAhB,OAAA,SAAA,GAAiC,8BAAjC,OAAA,SAAA,GAAA,KAAA,IAA6D,OAAA;AAEzD,cAAA,OAAO,QAAQ,kBAAkB;AAEvC,YAAI,OAAO,UAAU;AACnB,cAAI,cAAc,IAAI,KAAK,QAAQ,QAAQ,CAAC,GAAG;AAC7C;UAAA;AAGF,wBAAc,IAAI,KAAK,QAAQ,QAAQ,CAAC;AAKxC,cAAI,YAAY,aAAa,QAAQ,QAAQ,MAAM,QAAW;AAC1D,oBAAgB,kBAAkB;AACpC;UAAA;QACF,OACK;AAEC,gBAAA,mBAAmB,OAAO,UAAW;YACzC,oBAAoB,KAAK,QAAQ,QAAQ;UAC3C;AAGI,cAAA,oBAAoB,CAAC,iBAAiB,UAAU;AAClD,6BAAiB,WAAW;AAC5B,oBAAQ,aAAa,gBAAgB;UAAA;QACvC;MAEJ;MACA,0BAA0B,CACxB,SACA,YACG;;AAGG,cAAA,OAAO,QAAQ,kBAAkB;AACvC,YACE,OAAO,YACP,CAAE,QAAgB,mBAClB,YAAY,aAAa,QAAQ,QAAQ,MAAM,UAC/C,CAAC,kBAAkB,IAAI,KAAK,QAAQ,QAAQ,CAAC,GAC7C;AACA,4BAAkB,IAAI,KAAK,QAAQ,QAAQ,CAAC;AAE5C,iBAAO,UAAW;YAChB,oBAAoB,KAAK,QAAQ,QAAQ;YACzC,UAAU,aAAa;cACrB,yBAAyB,MAAM;cAC/B,sBAAsB,CAAC,UACrB,KAAK,MAAM,QAAQ,MAAM,KAAK,QAAQ,QAAQ;YACjD,CAAA;UACH;QAAA;AAIA,SAAA,MAAA,KAAA,gBAAgB,YAAhB,OAAA,SAAA,GAAiC,6BAAjC,OAAA,SAAA,GAAA;UAAA;UACA;UACA;QAAA;MACF;IACF;EACF,CACD;AAED,QAAM,YAAY,OAAO;AACzB,SAAO,UAAU;IACf,GAAG,OAAO;IACV,WAAW,MAAM;;AACR,aAAA;QACL,IAAG,KAAA,UAAU,cAAV,OAAA,SAAA,GAAA,KAAA,SAAA;;QAEH,uBAAuB,UAAU,WAAW;MAC9C;IACF;IACA,SAAS,CAAC,eAAoB;;AAC5B,OAAA,KAAA,UAAU,YAAV,OAAA,SAAA,GAAA,KAAA,WAAoB,UAAA;AAEZ,cAAA,aAAa,WAAW,qBAAqB;IACvD;IACA,SAAS;MACP,GAAG,UAAU;;MAEb;IACF;;IAEA,MAAM,CAAC,EAAE,SAAA,MAAe;AAChB,YAAA,SAAS,UAAU,QAAQ;AACjC,iBAAA,wBACG,qBAAoB,EAAA,QAAQ,aAC3B,cAAC,wBAAA,QAAA,EAAQ,SAAA,CAAS,EACpB,CAAA;IAAA;EAGN;AAEO,SAAA;AACT;",
  "names": []
}
