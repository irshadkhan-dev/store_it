{
  "version": 3,
  "sources": ["../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/Asset.tsx", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/createIsomorphicFn.ts", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/headers.ts", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/registerGlobalMiddleware.ts", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/serializer.ts", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/createServerFn.ts", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/createMiddleware.ts", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/envOnly.ts", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/json.ts", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/ssr-client.tsx", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/useServerFn.ts", "../../../../.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/src/serverFnFetcher.tsx"],
  "sourcesContent": ["/* eslint-disable @eslint-react/dom/no-dangerously-set-innerhtml */\nimport type { RouterManagedTag } from '@tanstack/react-router'\n\nexport function Asset({ tag, attrs, children }: RouterManagedTag): any {\n  switch (tag) {\n    case 'title':\n      return (\n        <title {...attrs} suppressHydrationWarning>\n          {children}\n        </title>\n      )\n    case 'meta':\n      return <meta {...attrs} suppressHydrationWarning />\n    case 'link':\n      return <link {...attrs} suppressHydrationWarning />\n    case 'style':\n      return (\n        <style\n          {...attrs}\n          dangerouslySetInnerHTML={{ __html: children as any }}\n        />\n      )\n    case 'script':\n      if ((attrs as any) && (attrs as any).src) {\n        return <script {...attrs} suppressHydrationWarning />\n      }\n      if (typeof children === 'string')\n        return (\n          <script\n            {...attrs}\n            dangerouslySetInnerHTML={{\n              __html: children,\n            }}\n            suppressHydrationWarning\n          />\n        )\n      return null\n    default:\n      return null\n  }\n}\n", "// a function that can have different implementations on the client and server.\n// implementations not provided will default to a no-op function.\n\nexport type IsomorphicFn<\n  TArgs extends Array<any> = [],\n  TServer = undefined,\n  TClient = undefined,\n> = (...args: TArgs) => TServer | TClient\n\nexport interface ServerOnlyFn<TArgs extends Array<any>, TServer>\n  extends IsomorphicFn<TArgs, TServer> {\n  client: <TClient>(\n    clientImpl: (...args: TArgs) => TClient,\n  ) => IsomorphicFn<TArgs, TServer, TClient>\n}\n\nexport interface ClientOnlyFn<TArgs extends Array<any>, TClient>\n  extends IsomorphicFn<TArgs, undefined, TClient> {\n  server: <TServer>(\n    serverImpl: (...args: TArgs) => TServer,\n  ) => IsomorphicFn<TArgs, TServer, TClient>\n}\n\nexport interface IsomorphicFnBase extends IsomorphicFn {\n  server: <TArgs extends Array<any>, TServer>(\n    serverImpl: (...args: TArgs) => TServer,\n  ) => ServerOnlyFn<TArgs, TServer>\n  client: <TArgs extends Array<any>, TClient>(\n    clientImpl: (...args: TArgs) => TClient,\n  ) => ClientOnlyFn<TArgs, TClient>\n}\n\n// this is a dummy function, it will be replaced by the transformer\nexport function createIsomorphicFn(): IsomorphicFnBase {\n  return null!\n}\n", "import type { OutgoingHttpHeaders } from 'node:http2'\n\n// A utility function to turn HeadersInit into an object\nexport function headersInitToObject(\n  headers: HeadersInit,\n): Record<keyof OutgoingHttpHeaders, string> {\n  const obj: Record<keyof OutgoingHttpHeaders, string> = {}\n  const headersInstance = new Headers(headers)\n  for (const [key, value] of headersInstance.entries()) {\n    obj[key] = value\n  }\n  return obj\n}\n\ntype AnyHeaders =\n  | Headers\n  | HeadersInit\n  | Record<string, string>\n  | Array<[string, string]>\n  | OutgoingHttpHeaders\n  | undefined\n\n// Helper function to convert various HeaderInit types to a Headers instance\nfunction toHeadersInstance(init: AnyHeaders) {\n  if (init instanceof Headers) {\n    return new Headers(init)\n  } else if (Array.isArray(init)) {\n    return new Headers(init)\n  } else if (typeof init === 'object') {\n    return new Headers(init as HeadersInit)\n  } else {\n    return new Headers()\n  }\n}\n\n// Function to merge headers with proper overrides\nexport function mergeHeaders(...headers: Array<AnyHeaders>) {\n  return headers.reduce((acc: Headers, header) => {\n    const headersInstance = toHeadersInstance(header)\n    for (const [key, value] of headersInstance.entries()) {\n      acc.set(key, value)\n    }\n    return acc\n  }, new Headers())\n}\n", "import type { AnyMiddleware } from './createMiddleware'\n\nexport const globalMiddleware: Array<AnyMiddleware> = []\n\nexport function registerGlobalMiddleware(options: {\n  middleware: Array<AnyMiddleware>\n}) {\n  globalMiddleware.push(...options.middleware)\n}\n", "import { isPlainObject } from '@tanstack/react-router'\nimport type { StartSerializer } from '@tanstack/react-router'\n\nexport const startSerializer: StartSerializer = {\n  stringify: (value: any) =>\n    JSON.stringify(value, function replacer(key, val) {\n      const ogVal = this[key]\n      const serializer = serializers.find((t) => t.stringifyCondition(ogVal))\n\n      if (serializer) {\n        return serializer.stringify(ogVal)\n      }\n\n      return val\n    }),\n  parse: (value: string) =>\n    JSON.parse(value, function parser(key, val) {\n      const ogVal = this[key]\n      if (isPlainObject(ogVal)) {\n        const serializer = serializers.find((t) => t.parseCondition(ogVal))\n\n        if (serializer) {\n          return serializer.parse(ogVal)\n        }\n      }\n\n      return val\n    }),\n  encode: (value: any) => {\n    // When encoding, dive first\n    if (Array.isArray(value)) {\n      return value.map((v) => startSerializer.encode(v))\n    }\n\n    if (isPlainObject(value)) {\n      return Object.fromEntries(\n        Object.entries(value).map(([key, v]) => [\n          key,\n          startSerializer.encode(v),\n        ]),\n      )\n    }\n\n    const serializer = serializers.find((t) => t.stringifyCondition(value))\n    if (serializer) {\n      return serializer.stringify(value)\n    }\n\n    return value\n  },\n  decode: (value: any) => {\n    // Attempt transform first\n    if (isPlainObject(value)) {\n      const serializer = serializers.find((t) => t.parseCondition(value))\n      if (serializer) {\n        return serializer.parse(value)\n      }\n    }\n\n    if (Array.isArray(value)) {\n      return value.map((v) => startSerializer.decode(v))\n    }\n\n    if (isPlainObject(value)) {\n      return Object.fromEntries(\n        Object.entries(value).map(([key, v]) => [\n          key,\n          startSerializer.decode(v),\n        ]),\n      )\n    }\n\n    return value\n  },\n}\n\nconst createSerializer = <TKey extends string, TInput, TSerialized>(\n  key: TKey,\n  check: (value: any) => value is TInput,\n  toValue: (value: TInput) => TSerialized,\n  fromValue: (value: TSerialized) => TInput,\n) => ({\n  key,\n  stringifyCondition: check,\n  stringify: (value: any) => ({ [`$${key}`]: toValue(value) }),\n  parseCondition: (value: any) => Object.hasOwn(value, `$${key}`),\n  parse: (value: any) => fromValue(value[`$${key}`]),\n})\n\n// Keep these ordered by predicted frequency\n// Make sure to keep DefaultSerializable in sync with these serializers\n// Also, make sure that they are unit tested in serializer.test.tsx\nconst serializers = [\n  createSerializer(\n    // Key\n    'undefined',\n    // Check\n    (v): v is undefined => v === undefined,\n    // To\n    () => 0,\n    // From\n    () => undefined,\n  ),\n  createSerializer(\n    // Key\n    'date',\n    // Check\n    (v): v is Date => v instanceof Date,\n    // To\n    (v) => v.toISOString(),\n    // From\n    (v) => new Date(v),\n  ),\n  createSerializer(\n    // Key\n    'error',\n    // Check\n    (v): v is Error => v instanceof Error,\n    // To\n    (v) => ({\n      ...v,\n      message: v.message,\n      stack: process.env.NODE_ENV === 'development' ? v.stack : undefined,\n      cause: v.cause,\n    }),\n    // From\n    (v) => Object.assign(new Error(v.message), v),\n  ),\n  createSerializer(\n    // Key\n    'formData',\n    // Check\n    (v): v is FormData => v instanceof FormData,\n    // To\n    (v) => {\n      const entries: Record<\n        string,\n        Array<FormDataEntryValue> | FormDataEntryValue\n      > = {}\n      v.forEach((value, key) => {\n        const entry = entries[key]\n        if (entry !== undefined) {\n          if (Array.isArray(entry)) {\n            entry.push(value)\n          } else {\n            entries[key] = [entry, value]\n          }\n        } else {\n          entries[key] = value\n        }\n      })\n      return entries\n    },\n    // From\n    (v) => {\n      const formData = new FormData()\n      Object.entries(v).forEach(([key, value]) => {\n        if (Array.isArray(value)) {\n          value.forEach((val) => formData.append(key, val))\n        } else {\n          formData.append(key, value)\n        }\n      })\n      return formData\n    },\n  ),\n] as const\n", "import { isNotFound, isRedirect, warning } from '@tanstack/react-router'\nimport { mergeHeaders } from './headers'\nimport { globalMiddleware } from './registerGlobalMiddleware'\nimport { startSerializer } from './serializer'\nimport type {\n  AnyValidator,\n  Constrain,\n  Expand,\n  ResolveValidatorInput,\n  SerializerParse,\n  SerializerStringify,\n  SerializerStringifyBy,\n  Validator,\n} from '@tanstack/react-router'\nimport type {\n  AnyMiddleware,\n  AssignAllServerContext,\n  IntersectAllValidatorInputs,\n  IntersectAllValidatorOutputs,\n  MiddlewareClientFnResult,\n  MiddlewareServerFnResult,\n} from './createMiddleware'\n\nexport interface JsonResponse<TData> extends Response {\n  json: () => Promise<TData>\n}\n\nexport type CompiledFetcherFnOptions = {\n  method: Method\n  data: unknown\n  headers?: HeadersInit\n  context?: any\n}\n\nexport type Fetcher<TMiddlewares, TValidator, TResponse> =\n  undefined extends IntersectAllValidatorInputs<TMiddlewares, TValidator>\n    ? OptionalFetcher<TMiddlewares, TValidator, TResponse>\n    : RequiredFetcher<TMiddlewares, TValidator, TResponse>\n\nexport interface FetcherBase {\n  url: string\n  __executeServer: (opts: {\n    method: Method\n    data: unknown\n    headers?: HeadersInit\n    context?: any\n  }) => Promise<unknown>\n}\n\nexport interface OptionalFetcher<TMiddlewares, TValidator, TResponse>\n  extends FetcherBase {\n  (\n    ...args: [options?: OptionalFetcherDataOptions<TMiddlewares, TValidator>]\n  ): Promise<FetcherData<TResponse>>\n}\n\nexport interface RequiredFetcher<TMiddlewares, TValidator, TResponse>\n  extends FetcherBase {\n  (\n    opts: RequiredFetcherDataOptions<TMiddlewares, TValidator>,\n  ): Promise<FetcherData<TResponse>>\n}\n\nexport type FetcherBaseOptions = {\n  headers?: HeadersInit\n}\n\nexport interface RequiredFetcherDataOptions<TMiddlewares, TValidator>\n  extends FetcherBaseOptions {\n  data: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n}\n\nexport interface OptionalFetcherDataOptions<TMiddlewares, TValidator>\n  extends FetcherBaseOptions {\n  data?: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n}\n\nexport type FetcherData<TResponse> =\n  TResponse extends JsonResponse<any>\n    ? SerializerParse<ReturnType<TResponse['json']>>\n    : SerializerParse<TResponse>\n\nexport type RscStream<T> = {\n  __cacheState: T\n}\n\nexport type Method = 'GET' | 'POST'\n\nexport type ServerFn<TMethod, TMiddlewares, TValidator, TResponse> = (\n  ctx: ServerFnCtx<TMethod, TMiddlewares, TValidator>,\n) => Promise<SerializerStringify<TResponse>> | SerializerStringify<TResponse>\n\nexport interface ServerFnCtx<TMethod, TMiddlewares, TValidator> {\n  method: TMethod\n  data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TValidator>>\n  context: Expand<AssignAllServerContext<TMiddlewares>>\n}\n\nexport type CompiledFetcherFn<TResponse> = {\n  (\n    opts: CompiledFetcherFnOptions & ServerFnBaseOptions<Method>,\n  ): Promise<TResponse>\n  url: string\n}\n\ntype ServerFnBaseOptions<\n  TMethod extends Method = 'GET',\n  TResponse = unknown,\n  TMiddlewares = unknown,\n  TInput = unknown,\n> = {\n  method: TMethod\n  validateClient?: boolean\n  middleware?: Constrain<TMiddlewares, ReadonlyArray<AnyMiddleware>>\n  validator?: ConstrainValidator<TInput>\n  extractedFn?: CompiledFetcherFn<TResponse>\n  serverFn?: ServerFn<TMethod, TMiddlewares, TInput, TResponse>\n  filename: string\n  functionId: string\n}\n\nexport type ValidatorSerializerStringify<TValidator> = Validator<\n  SerializerStringifyBy<\n    ResolveValidatorInput<TValidator>,\n    Date | undefined | FormData\n  >,\n  any\n>\n\nexport type ConstrainValidator<TValidator> = unknown extends TValidator\n  ? TValidator\n  : Constrain<TValidator, ValidatorSerializerStringify<TValidator>>\n\nexport interface ServerFnMiddleware<TMethod extends Method, TValidator> {\n  middleware: <const TNewMiddlewares = undefined>(\n    middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>,\n  ) => ServerFnAfterMiddleware<TMethod, TNewMiddlewares, TValidator>\n}\n\nexport interface ServerFnAfterMiddleware<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnValidator<TMethod, TMiddlewares>,\n    ServerFnHandler<TMethod, TMiddlewares, TValidator> {}\n\nexport type ValidatorFn<TMethod extends Method, TMiddlewares> = <TValidator>(\n  validator: ConstrainValidator<TValidator>,\n) => ServerFnAfterValidator<TMethod, TMiddlewares, TValidator>\n\nexport interface ServerFnValidator<TMethod extends Method, TMiddlewares> {\n  validator: ValidatorFn<TMethod, TMiddlewares>\n}\n\nexport interface ServerFnAfterValidator<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> extends ServerFnMiddleware<TMethod, TValidator>,\n    ServerFnHandler<TMethod, TMiddlewares, TValidator> {}\n\nexport interface ServerFnHandler<\n  TMethod extends Method,\n  TMiddlewares,\n  TValidator,\n> {\n  handler: <TNewResponse>(\n    fn?: ServerFn<TMethod, TMiddlewares, TValidator, TNewResponse>,\n  ) => Fetcher<TMiddlewares, TValidator, TNewResponse>\n}\n\nexport interface ServerFnBuilder<TMethod extends Method = 'GET'>\n  extends ServerFnMiddleware<TMethod, undefined>,\n    ServerFnValidator<TMethod, undefined>,\n    ServerFnHandler<TMethod, undefined, undefined> {\n  options: ServerFnBaseOptions<TMethod, unknown, undefined, undefined>\n}\n\nexport function createServerFn<\n  TMethod extends Method,\n  TResponse = unknown,\n  TMiddlewares = undefined,\n  TValidator = undefined,\n>(\n  options?: {\n    method: TMethod\n  },\n  __opts?: ServerFnBaseOptions<TMethod, TResponse, TMiddlewares, TValidator>,\n): ServerFnBuilder<TMethod> {\n  const resolvedOptions = (__opts || options || {}) as ServerFnBaseOptions<\n    TMethod,\n    TResponse,\n    TMiddlewares,\n    TValidator\n  >\n\n  if (typeof resolvedOptions.method === 'undefined') {\n    resolvedOptions.method = 'GET' as TMethod\n  }\n\n  return {\n    options: resolvedOptions as any,\n    middleware: (middleware) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { middleware }),\n      ) as any\n    },\n    validator: (validator) => {\n      return createServerFn<TMethod, TResponse, TMiddlewares, TValidator>(\n        undefined,\n        Object.assign(resolvedOptions, { validator }),\n      ) as any\n    },\n    handler: (...args) => {\n      // This function signature changes due to AST transformations\n      // in the babel plugin. We need to cast it to the correct\n      // function signature post-transformation\n      const [extractedFn, serverFn] = args as unknown as [\n        CompiledFetcherFn<TResponse>,\n        ServerFn<TMethod, TMiddlewares, TValidator, TResponse>,\n      ]\n\n      // Keep the original function around so we can use it\n      // in the server environment\n      Object.assign(resolvedOptions, {\n        ...extractedFn,\n        extractedFn,\n        serverFn,\n      })\n\n      if (!extractedFn.url) {\n        console.warn(extractedFn)\n        warning(\n          false,\n          `createServerFn must be called with a function that has a 'url' property. Ensure that the @tanstack/start-plugin is ordered **before** the @tanstack/server-functions-plugin.`,\n        )\n      }\n\n      const resolvedMiddleware = [\n        ...(resolvedOptions.middleware || []),\n        serverFnBaseToMiddleware(resolvedOptions),\n      ]\n\n      // We want to make sure the new function has the same\n      // properties as the original function\n      return Object.assign(\n        async (opts?: CompiledFetcherFnOptions) => {\n          // Start by executing the client-side middleware chain\n          return executeMiddleware(resolvedMiddleware, 'client', {\n            ...extractedFn,\n            method: resolvedOptions.method,\n            data: opts?.data as any,\n            headers: opts?.headers,\n            context: {},\n          }).then((d) => {\n            if (d.error) throw d.error\n            return d.result\n          })\n        },\n        {\n          // This copies over the URL, function ID and filename\n          ...extractedFn,\n          // The extracted function on the server-side calls\n          // this function\n          __executeServer: async (opts: any) => {\n            const parsedOpts =\n              opts instanceof FormData ? extractFormDataContext(opts) : opts\n\n            const result = await executeMiddleware(\n              resolvedMiddleware,\n              'server',\n              {\n                ...extractedFn,\n                ...parsedOpts,\n              },\n            ).then((d) => ({\n              // Only send the result and sendContext back to the client\n              result: d.result,\n              error: d.error,\n              context: d.sendContext,\n            }))\n\n            return result\n          },\n        },\n      ) as any\n    },\n  }\n}\n\nfunction extractFormDataContext(formData: FormData) {\n  const serializedContext = formData.get('__TSR_CONTEXT')\n  formData.delete('__TSR_CONTEXT')\n\n  if (typeof serializedContext !== 'string') {\n    return {\n      context: {},\n      data: formData,\n    }\n  }\n\n  try {\n    const context = startSerializer.parse(serializedContext)\n    return {\n      context,\n      data: formData,\n    }\n  } catch {\n    return {\n      data: formData,\n    }\n  }\n}\n\nfunction flattenMiddlewares(\n  middlewares: Array<AnyMiddleware>,\n): Array<AnyMiddleware> {\n  const seen = new Set<AnyMiddleware>()\n  const flattened: Array<AnyMiddleware> = []\n\n  const recurse = (middleware: Array<AnyMiddleware>) => {\n    middleware.forEach((m) => {\n      if (m.options.middleware) {\n        recurse(m.options.middleware)\n      }\n\n      if (!seen.has(m)) {\n        seen.add(m)\n        flattened.push(m)\n      }\n    })\n  }\n\n  recurse(middlewares)\n\n  return flattened\n}\n\nexport type MiddlewareOptions = {\n  method: Method\n  data: any\n  headers?: HeadersInit\n  sendContext?: any\n  context?: any\n}\n\nexport type MiddlewareResult = MiddlewareOptions & {\n  result?: unknown\n  error?: unknown\n}\n\nexport type NextFn = (ctx: MiddlewareResult) => Promise<MiddlewareResult>\n\nexport type MiddlewareFn = (\n  ctx: MiddlewareOptions & {\n    next: NextFn\n  },\n) => Promise<MiddlewareResult>\n\nconst applyMiddleware = async (\n  middlewareFn: MiddlewareFn,\n  ctx: MiddlewareOptions,\n  nextFn: NextFn,\n) => {\n  return middlewareFn({\n    ...ctx,\n    next: (async (userCtx: MiddlewareResult | undefined = {} as any) => {\n      // Return the next middleware\n      return nextFn({\n        ...ctx,\n        ...userCtx,\n        context: {\n          ...ctx.context,\n          ...userCtx.context,\n        },\n        sendContext: {\n          ...ctx.sendContext,\n          ...(userCtx.sendContext ?? {}),\n        },\n        headers: mergeHeaders(ctx.headers, userCtx.headers),\n        result:\n          userCtx.result !== undefined ? userCtx.result : (ctx as any).result,\n        error: userCtx.error ?? (ctx as any).error,\n      })\n    }) as any,\n  })\n}\n\nfunction execValidator(validator: AnyValidator, input: unknown): unknown {\n  if (validator == null) return {}\n\n  if ('~standard' in validator) {\n    const result = validator['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new Error('Async validation not supported')\n\n    if (result.issues)\n      throw new Error(JSON.stringify(result.issues, undefined, 2))\n\n    return result.value\n  }\n\n  if ('parse' in validator) {\n    return validator.parse(input)\n  }\n\n  if (typeof validator === 'function') {\n    return validator(input)\n  }\n\n  throw new Error('Invalid validator type!')\n}\n\nasync function executeMiddleware(\n  middlewares: Array<AnyMiddleware>,\n  env: 'client' | 'server',\n  opts: MiddlewareOptions,\n): Promise<MiddlewareResult> {\n  const flattenedMiddlewares = flattenMiddlewares([\n    ...globalMiddleware,\n    ...middlewares,\n  ])\n\n  const next: NextFn = async (ctx) => {\n    // Get the next middleware\n    const nextMiddleware = flattenedMiddlewares.shift()\n\n    // If there are no more middlewares, return the context\n    if (!nextMiddleware) {\n      return ctx\n    }\n\n    if (\n      nextMiddleware.options.validator &&\n      (env === 'client' ? nextMiddleware.options.validateClient : true)\n    ) {\n      // Execute the middleware's input function\n      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data)\n    }\n\n    const middlewareFn = (\n      env === 'client'\n        ? nextMiddleware.options.client\n        : nextMiddleware.options.server\n    ) as MiddlewareFn | undefined\n\n    if (middlewareFn) {\n      // Execute the middleware\n      return applyMiddleware(middlewareFn, ctx, async (newCtx) => {\n        // If there is a clientAfter function and we are on the client\n        const clientAfter = nextMiddleware.options.clientAfter as\n          | MiddlewareFn\n          | undefined\n\n        if (env === 'client' && clientAfter) {\n          // We need to await the next middleware and get the result\n          const result = await next(newCtx)\n\n          // Then we can execute the clientAfter function\n          return applyMiddleware(\n            clientAfter,\n            {\n              ...newCtx,\n              ...result,\n            },\n            // Identity, because there \"next\" is just returning\n            (d: any) => d,\n          )\n        }\n\n        return next(newCtx).catch((error) => {\n          if (isRedirect(error) || isNotFound(error)) {\n            return {\n              ...newCtx,\n              error,\n            }\n          }\n\n          throw error\n        })\n      })\n    }\n\n    return next(ctx)\n  }\n\n  // Start the middleware chain\n  return next({\n    ...opts,\n    headers: opts.headers || {},\n    sendContext: opts.sendContext || {},\n    context: opts.context || {},\n  })\n}\n\nfunction serverFnBaseToMiddleware(\n  options: ServerFnBaseOptions<any, any, any, any>,\n): AnyMiddleware {\n  return {\n    _types: undefined!,\n    options: {\n      validator: options.validator,\n      validateClient: options.validateClient,\n      client: async ({ next, sendContext, ...ctx }) => {\n        // Execute the extracted function\n        // but not before serializing the context\n        const serverCtx = await options.extractedFn?.({\n          ...ctx,\n          // switch the sendContext over to context\n          context: sendContext,\n        })\n\n        return next(serverCtx) as unknown as MiddlewareClientFnResult<any, any>\n      },\n      server: async ({ next, ...ctx }) => {\n        // Execute the server function\n        const result = await options.serverFn?.(ctx)\n\n        return next({\n          ...ctx,\n          result,\n        } as any) as unknown as MiddlewareServerFnResult<any, any>\n      },\n    },\n  }\n}\n", "import type { ConstrainValidator, Method } from './createServerFn'\nimport type {\n  Assign,\n  Constrain,\n  Expand,\n  IntersectAssign,\n  ResolveValidatorInput,\n  ResolveValidatorOutput,\n  SerializerStringify,\n} from '@tanstack/react-router'\n\nexport type AssignAllMiddleware<\n  TMiddlewares,\n  TType extends keyof AnyMiddleware['_types'],\n  TAcc = undefined,\n> = TMiddlewares extends readonly [\n  infer TMiddleware extends AnyMiddleware,\n  ...infer TRest,\n]\n  ? AssignAllMiddleware<\n      TRest,\n      TType,\n      Assign<TAcc, TMiddleware['_types'][TType]>\n    >\n  : TAcc\n\nexport type AssignAllClientAfterContext<\n  TMiddlewares,\n  TClientContext = undefined,\n  TClientAfterContext = undefined,\n> = unknown extends TClientContext\n  ? TClientContext\n  : Assign<\n      AssignAllMiddleware<TMiddlewares, 'allClientAfterContext'>,\n      Assign<TClientContext, TClientAfterContext>\n    >\n\n/**\n * Recursively resolve the client context type produced by a sequence of middleware\n */\nexport type AssignAllClientContext<\n  TMiddlewares,\n  TContext = undefined,\n> = unknown extends TContext\n  ? TContext\n  : Assign<AssignAllMiddleware<TMiddlewares, 'allClientContext'>, TContext>\n\n/**\n * Recursively resolve the server context type produced by a sequence of middleware\n */\nexport type AssignAllServerContext<\n  TMiddlewares,\n  TContext = undefined,\n> = unknown extends TContext\n  ? TContext\n  : Assign<AssignAllMiddleware<TMiddlewares, 'allServerContext'>, TContext>\n\nexport type IntersectAllMiddleware<\n  TMiddlewares,\n  TType extends keyof AnyMiddleware['_types'],\n  TAcc = undefined,\n> = TMiddlewares extends readonly [\n  infer TMiddleware extends AnyMiddleware,\n  ...infer TRest,\n]\n  ? IntersectAllMiddleware<\n      TRest,\n      TType,\n      IntersectAssign<TAcc, TMiddleware['_types'][TType]>\n    >\n  : TAcc\n\n/**\n * Recursively resolve the input type produced by a sequence of middleware\n */\nexport type IntersectAllValidatorInputs<TMiddlewares, TValidator> =\n  unknown extends TValidator\n    ? TValidator\n    : IntersectAssign<\n        IntersectAllMiddleware<TMiddlewares, 'allInput'>,\n        TValidator extends undefined\n          ? undefined\n          : ResolveValidatorInput<TValidator>\n      >\n/**\n * Recursively merge the output type produced by a sequence of middleware\n */\nexport type IntersectAllValidatorOutputs<TMiddlewares, TValidator> =\n  unknown extends TValidator\n    ? TValidator\n    : IntersectAssign<\n        IntersectAllMiddleware<TMiddlewares, 'allOutput'>,\n        TValidator extends undefined\n          ? undefined\n          : ResolveValidatorOutput<TValidator>\n      >\n\nexport interface MiddlewareOptions<\n  in out TMiddlewares,\n  in out TValidator,\n  in out TServerContext,\n  in out TClientContext,\n> {\n  validateClient?: boolean\n  middleware?: TMiddlewares\n  validator?: ConstrainValidator<TValidator>\n  client?: MiddlewareClientFn<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext\n  >\n  server?: MiddlewareServerFn<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    unknown,\n    unknown\n  >\n  clientAfter?: MiddlewareClientAfterFn<\n    TMiddlewares,\n    TValidator,\n    TClientContext,\n    unknown,\n    unknown\n  >\n}\n\nexport type MiddlewareServerNextFn = <\n  TNewServerContext = undefined,\n  TNewClientAfterContext = undefined,\n>(ctx?: {\n  context?: TNewServerContext\n  sendContext?: SerializerStringify<TNewClientAfterContext>\n}) => Promise<\n  ServerResultWithContext<TNewServerContext, TNewClientAfterContext>\n>\n\nexport interface MiddlewareServerFnOptions<\n  in out TMiddlewares,\n  in out TValidator,\n  in out TServerContext,\n> {\n  data: Expand<IntersectAllValidatorOutputs<TMiddlewares, TValidator>>\n  context: Expand<AssignAllServerContext<TMiddlewares, TServerContext>>\n  next: MiddlewareServerNextFn\n  method: Method\n  filename: string\n  functionId: string\n}\n\nexport type MiddlewareServerFn<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TNewServerContext,\n  TNewClientAfterContext,\n> = (\n  options: MiddlewareServerFnOptions<TMiddlewares, TValidator, TServerContext>,\n) => MiddlewareServerFnResult<TNewServerContext, TNewClientAfterContext>\n\nexport type MiddlewareServerFnResult<TServerContext, TClientAfterContext> =\n  | Promise<ServerResultWithContext<TServerContext, TClientAfterContext>>\n  | ServerResultWithContext<TServerContext, TClientAfterContext>\n\nexport type MiddlewareClientNextFn = <\n  TNewServerContext = undefined,\n  TNewClientContext = undefined,\n>(ctx?: {\n  context?: TNewClientContext\n  sendContext?: SerializerStringify<TNewServerContext>\n  headers?: HeadersInit\n}) => Promise<ClientResultWithContext<TNewServerContext, TNewClientContext>>\n\nexport interface MiddlewareClientFnOptions<\n  in out TMiddlewares,\n  in out TValidator,\n> {\n  data: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n  context: Expand<AssignAllClientContext<TMiddlewares>>\n  sendContext?: unknown // cc Chris Horobin\n  method: Method\n  next: MiddlewareClientNextFn\n  filename: string\n  functionId: string\n}\n\nexport type MiddlewareClientFn<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n> = (\n  options: MiddlewareClientFnOptions<TMiddlewares, TValidator>,\n) => MiddlewareClientFnResult<TServerContext, TClientContext>\n\nexport type MiddlewareClientFnResult<TServerContext, TClientContext> =\n  | Promise<ClientResultWithContext<TServerContext, TClientContext>>\n  | ClientResultWithContext<TServerContext, TClientContext>\n\nexport type MiddlewareClientAfterNextFn = <\n  TNewClientAfterContext = undefined,\n>(ctx?: {\n  context?: TNewClientAfterContext\n  sendContext?: never\n  headers?: HeadersInit\n}) => Promise<ClientAfterResultWithContext<TNewClientAfterContext>>\n\nexport interface MiddlewareClientAfterFnOptions<\n  in out TMiddlewares,\n  in out TValidator,\n  in out TClientContext,\n  in out TClientAfterContext,\n> {\n  data: Expand<IntersectAllValidatorInputs<TMiddlewares, TValidator>>\n  context: Expand<\n    AssignAllClientAfterContext<\n      TMiddlewares,\n      TClientContext,\n      TClientAfterContext\n    >\n  >\n  method: Method\n  next: MiddlewareClientAfterNextFn\n}\n\nexport type MiddlewareClientAfterFn<\n  TMiddlewares,\n  TValidator,\n  TClientContext,\n  TClientAfterContext,\n  TNewClientAfterContext,\n> = (\n  options: MiddlewareClientAfterFnOptions<\n    TMiddlewares,\n    TValidator,\n    TClientContext,\n    TClientAfterContext\n  >,\n) => MiddlewareClientAfterFnResult<TNewClientAfterContext>\n\nexport type MiddlewareClientAfterFnResult<TNewClientAfterContext> =\n  | Promise<ClientAfterResultWithContext<TNewClientAfterContext>>\n  | ClientAfterResultWithContext<TNewClientAfterContext>\n\nexport type ServerResultWithContext<TContext, TClientAfterContext> = {\n  'use functions must return the result of next()': true\n  context: TContext\n  clientAfterContext: TClientAfterContext\n}\n\nexport type ClientAfterResultWithContext<TClientContext> = {\n  'use functions must return the result of next()': true\n  context: TClientContext\n  headers: HeadersInit\n}\n\nexport type ClientResultWithContext<TServerContext, TClientContext> = {\n  'use functions must return the result of next()': true\n  context: TClientContext\n  serverContext: TServerContext\n  headers: HeadersInit\n}\n\nexport type AnyMiddleware = MiddlewareTypes<any, any, any, any, any>\n\nexport interface MiddlewareTypes<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  _types: {\n    middlewares: TMiddlewares\n    input: ResolveValidatorInput<TValidator>\n    allInput: IntersectAllValidatorInputs<TMiddlewares, TValidator>\n    output: ResolveValidatorOutput<TValidator>\n    allOutput: IntersectAllValidatorOutputs<TMiddlewares, TValidator>\n    clientContext: TClientContext\n    allClientContext: AssignAllClientContext<TMiddlewares, TClientContext>\n    serverContext: TServerContext\n    allServerContext: AssignAllServerContext<TMiddlewares, TServerContext>\n    clientAfterContext: TClientAfterContext\n    allClientAfterContext: AssignAllClientAfterContext<\n      TMiddlewares,\n      TClientContext,\n      TClientAfterContext\n    >\n    validator: TValidator\n  }\n  options: MiddlewareOptions<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext\n  >\n}\n\nexport interface MiddlewareAfterValidator<TMiddlewares, TValidator>\n  extends MiddlewareTypes<\n      TMiddlewares,\n      TValidator,\n      undefined,\n      undefined,\n      undefined\n    >,\n    MiddlewareServer<TMiddlewares, TValidator, undefined, undefined>,\n    MiddlewareClient<TMiddlewares, TValidator> {}\n\nexport interface MiddlewareValidator<TMiddlewares> {\n  validator: <TNewValidator>(\n    input: ConstrainValidator<TNewValidator>,\n  ) => MiddlewareAfterValidator<TMiddlewares, TNewValidator>\n}\n\nexport interface MiddlewareClientAfter<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> {\n  clientAfter: <TNewClientAfterContext = undefined>(\n    clientAfter: MiddlewareClientAfterFn<\n      TMiddlewares,\n      TValidator,\n      TClientContext,\n      TClientAfterContext,\n      TNewClientAfterContext\n    >,\n  ) => MiddlewareAfterServer<\n    TMiddlewares,\n    TValidator,\n    TServerContext,\n    TClientContext,\n    Assign<TClientAfterContext, TNewClientAfterContext>\n  >\n}\n\nexport interface MiddlewareAfterServer<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n  TClientAfterContext,\n> extends MiddlewareTypes<\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    >,\n    MiddlewareClientAfter<\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      TClientAfterContext\n    > {}\n\nexport interface MiddlewareServer<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n> {\n  server: <TNewServerContext = undefined, TNewClientAfterContext = undefined>(\n    server: MiddlewareServerFn<\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TNewServerContext,\n      TNewClientAfterContext\n    >,\n  ) => MiddlewareAfterServer<\n    TMiddlewares,\n    TValidator,\n    Assign<TServerContext, TNewServerContext>,\n    TClientContext,\n    TNewClientAfterContext\n  >\n}\n\nexport interface MiddlewareAfterClient<\n  TMiddlewares,\n  TValidator,\n  TServerContext,\n  TClientContext,\n> extends MiddlewareTypes<\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext,\n      undefined\n    >,\n    MiddlewareServer<\n      TMiddlewares,\n      TValidator,\n      TServerContext,\n      TClientContext\n    > {}\n\nexport interface MiddlewareClient<TMiddlewares, TValidator> {\n  client: <TNewServerContext = undefined, TNewClientContext = undefined>(\n    client: MiddlewareClientFn<\n      TMiddlewares,\n      TValidator,\n      TNewServerContext,\n      TNewClientContext\n    >,\n  ) => MiddlewareAfterClient<\n    TMiddlewares,\n    TValidator,\n    TNewServerContext,\n    TNewClientContext\n  >\n}\n\nexport interface MiddlewareAfterMiddleware<TMiddlewares>\n  extends MiddlewareTypes<\n      TMiddlewares,\n      undefined,\n      undefined,\n      undefined,\n      undefined\n    >,\n    MiddlewareServer<TMiddlewares, undefined, undefined, undefined>,\n    MiddlewareClient<TMiddlewares, undefined>,\n    MiddlewareValidator<TMiddlewares> {}\n\nexport interface Middleware extends MiddlewareAfterMiddleware<unknown> {\n  middleware: <const TNewMiddlewares = undefined>(\n    middlewares: Constrain<TNewMiddlewares, ReadonlyArray<AnyMiddleware>>,\n  ) => MiddlewareAfterMiddleware<TNewMiddlewares>\n}\n\nexport function createMiddleware(\n  options?: {\n    validateClient?: boolean\n  },\n  __opts?: MiddlewareOptions<unknown, undefined, undefined, undefined>,\n): Middleware {\n  // const resolvedOptions = (__opts || options) as MiddlewareOptions<\n  const resolvedOptions =\n    __opts ||\n    ((options || {}) as MiddlewareOptions<\n      unknown,\n      undefined,\n      undefined,\n      undefined\n    >)\n\n  return {\n    options: resolvedOptions as any,\n    middleware: (middleware: any) => {\n      return createMiddleware(\n        undefined,\n        Object.assign(resolvedOptions, { middleware }),\n      ) as any\n    },\n    validator: (validator: any) => {\n      return createMiddleware(\n        undefined,\n        Object.assign(resolvedOptions, { validator }),\n      ) as any\n    },\n    client: (client: any) => {\n      return createMiddleware(\n        undefined,\n        Object.assign(resolvedOptions, { client }),\n      ) as any\n    },\n    server: (server: any) => {\n      return createMiddleware(\n        undefined,\n        Object.assign(resolvedOptions, { server }),\n      ) as any\n    },\n    clientAfter: (clientAfter: any) => {\n      return createMiddleware(\n        undefined,\n        Object.assign(resolvedOptions, { clientAfter }),\n      ) as any\n    },\n  } as unknown as Middleware\n}\n", "type EnvOnlyFn = <TFn extends (...args: Array<any>) => any>(fn: TFn) => TFn\n\n// A function that will only be available in the server build\n// If called on the client, it will throw an error\nexport const serverOnly: EnvOnlyFn = (fn) => fn\n\n// A function that will only be available in the client build\n// If called on the server, it will throw an error\nexport const clientOnly: EnvOnlyFn = (fn) => fn\n", "import { mergeHeaders } from './headers'\nimport type { JsonResponse } from './createServerFn'\n\nexport function json<TData>(\n  payload: TData,\n  init?: ResponseInit,\n): JsonResponse<TData> {\n  return new Response(JSON.stringify(payload), {\n    ...init,\n    headers: mergeHeaders(\n      { 'content-type': 'application/json' },\n      init?.headers,\n    ),\n  })\n}\n", "import { isPlainObject } from '@tanstack/react-router'\n\nimport invariant from 'tiny-invariant'\n\nimport { startSerializer } from './serializer'\nimport type {\n  AnyRouter,\n  ControllablePromise,\n  DeferredPromiseState,\n  MakeRouteMatch,\n  Manifest,\n} from '@tanstack/react-router'\n\ndeclare global {\n  interface Window {\n    __TSR_SSR__?: StartSsrGlobal\n  }\n}\n\nexport interface StartSsrGlobal {\n  matches: Array<SsrMatch>\n  streamedValues: Record<\n    string,\n    {\n      value: any\n      parsed: any\n    }\n  >\n  cleanScripts: () => void\n  dehydrated?: any\n  initMatch: (match: SsrMatch) => void\n  resolvePromise: (opts: {\n    matchId: string\n    id: number\n    promiseState: DeferredPromiseState<any>\n  }) => void\n  injectChunk: (opts: { matchId: string; id: number; chunk: string }) => void\n  closeStream: (opts: { matchId: string; id: number }) => void\n}\n\nexport interface SsrMatch {\n  id: string\n  __beforeLoadContext: string\n  loaderData?: string\n  error?: string\n  extracted?: Array<ClientExtractedEntry>\n  updatedAt: MakeRouteMatch['updatedAt']\n  status: MakeRouteMatch['status']\n}\n\nexport type ClientExtractedEntry =\n  | ClientExtractedStream\n  | ClientExtractedPromise\n\nexport interface ClientExtractedPromise extends ClientExtractedBaseEntry {\n  type: 'promise'\n  value?: ControllablePromise<any>\n}\n\nexport interface ClientExtractedStream extends ClientExtractedBaseEntry {\n  type: 'stream'\n  value?: ReadableStream & { controller?: ReadableStreamDefaultController }\n}\n\nexport interface ClientExtractedBaseEntry {\n  type: string\n  path: Array<string>\n}\n\nexport interface ResolvePromiseState {\n  matchId: string\n  id: number\n  promiseState: DeferredPromiseState<any>\n}\n\nexport interface DehydratedRouter {\n  manifest: Manifest | undefined\n  dehydratedData: any\n}\n\nexport function hydrate(router: AnyRouter) {\n  invariant(\n    window.__TSR_SSR__?.dehydrated,\n    'Expected to find a dehydrated data on window.__TSR_SSR__.dehydrated... but we did not. Please file an issue!',\n  )\n\n  const { manifest, dehydratedData } = startSerializer.parse(\n    window.__TSR_SSR__.dehydrated,\n  ) as DehydratedRouter\n\n  router.ssr = {\n    manifest,\n    serializer: startSerializer,\n  }\n\n  router.clientSsr = {\n    getStreamedValue: <T,>(key: string): T | undefined => {\n      if (router.isServer) {\n        return undefined\n      }\n\n      const streamedValue = window.__TSR_SSR__?.streamedValues[key]\n\n      if (!streamedValue) {\n        return\n      }\n\n      if (!streamedValue.parsed) {\n        streamedValue.parsed = router.ssr!.serializer.parse(streamedValue.value)\n      }\n\n      return streamedValue.parsed\n    },\n  }\n\n  // Hydrate the router state\n  const matches = router.matchRoutes(router.state.location).map((match) => {\n    const route = router.looseRoutesById[match.routeId]!\n\n    // Right after hydration and before the first render, we need to rehydrate each match\n    // This includes rehydrating the loaderData and also using the beforeLoadContext\n    // to reconstruct any context that was serialized on the server\n\n    const dehydratedMatch = window.__TSR_SSR__!.matches.find(\n      (d) => d.id === match.id,\n    )\n\n    if (dehydratedMatch) {\n      Object.assign(match, dehydratedMatch)\n\n      const parentMatch = router.state.matches[match.index - 1]\n      const parentContext = parentMatch?.context ?? router.options.context ?? {}\n\n      // Handle beforeLoadContext\n      if (dehydratedMatch.__beforeLoadContext) {\n        match.__beforeLoadContext = router.ssr!.serializer.parse(\n          dehydratedMatch.__beforeLoadContext,\n        ) as any\n\n        match.context = {\n          ...parentContext,\n          ...match.context,\n          ...match.__beforeLoadContext,\n        }\n      }\n\n      // Handle loaderData\n      if (dehydratedMatch.loaderData) {\n        match.loaderData = router.ssr!.serializer.parse(\n          dehydratedMatch.loaderData,\n        )\n      }\n\n      // Handle error\n      if (dehydratedMatch.error) {\n        match.error = router.ssr!.serializer.parse(dehydratedMatch.error)\n      }\n\n      // Handle extracted\n      ;(match as unknown as SsrMatch).extracted?.forEach((ex) => {\n        deepMutableSetByPath(match, ['loaderData', ...ex.path], ex.value)\n      })\n    } else {\n      Object.assign(match, {\n        status: 'success',\n        updatedAt: Date.now(),\n      })\n    }\n\n    const headFnContent = route.options.head?.({\n      matches: router.state.matches,\n      match,\n      params: match.params,\n      loaderData: match.loaderData,\n    })\n\n    Object.assign(match, {\n      meta: headFnContent?.meta,\n      links: headFnContent?.links,\n      scripts: headFnContent?.scripts,\n    })\n\n    return match\n  })\n\n  router.__store.setState((s) => {\n    return {\n      ...s,\n      matches: matches,\n    }\n  })\n\n  // Allow the user to handle custom hydration data\n  router.options.hydrate?.(dehydratedData)\n}\n\nfunction deepMutableSetByPath<T>(obj: T, path: Array<string>, value: any) {\n  // mutable set by path retaining array and object references\n  if (path.length === 1) {\n    ;(obj as any)[path[0]!] = value\n  }\n\n  const [key, ...rest] = path\n\n  if (Array.isArray(obj)) {\n    deepMutableSetByPath(obj[Number(key)], rest, value)\n  } else if (isPlainObject(obj)) {\n    deepMutableSetByPath((obj as any)[key!], rest, value)\n  }\n}\n", "import { isRedirect, useRouter } from '@tanstack/react-router'\n\nexport function useServerFn<T extends (...deps: Array<any>) => Promise<any>>(\n  serverFn: T,\n): (...args: Parameters<T>) => ReturnType<T> {\n  const router = useRouter()\n\n  return (async (...args: Array<any>) => {\n    try {\n      const res = await serverFn(...args)\n\n      if (isRedirect(res)) {\n        throw res\n      }\n\n      return res\n    } catch (err) {\n      if (isRedirect(err)) {\n        const resolvedRedirect = router.resolveRedirect({\n          ...err,\n          _fromLocation: router.state.location,\n        })\n\n        return router.navigate(resolvedRedirect)\n      }\n\n      throw err\n    }\n  }) as any\n}\n", "import {\n  encode,\n  isNotFound,\n  isPlainObject,\n  isRedirect,\n} from '@tanstack/react-router'\nimport { startSerializer } from './serializer'\nimport type { MiddlewareOptions } from './createServerFn'\n\nexport async function serverFnFetcher(\n  url: string,\n  args: Array<any>,\n  handler: (url: string, requestInit: RequestInit) => Promise<Response>,\n) {\n  const _first = args[0]\n\n  // If createServerFn was used to wrap the fetcher,\n  // We need to handle the arguments differently\n  if (isPlainObject(_first) && _first.method) {\n    const first = _first as MiddlewareOptions\n    const type = first.data instanceof FormData ? 'formData' : 'payload'\n\n    // Arrange the headers\n    const headers = new Headers({\n      ...(type === 'payload'\n        ? {\n            'content-type': 'application/json',\n            accept: 'application/json',\n          }\n        : {}),\n      ...(first.headers instanceof Headers\n        ? Object.fromEntries(first.headers.entries())\n        : first.headers || {}),\n    })\n\n    // If the method is GET, we need to move the payload to the query string\n    if (first.method === 'GET') {\n      // If the method is GET, we need to move the payload to the query string\n      const encodedPayload = encode({\n        payload: startSerializer.stringify({\n          data: first.data,\n          context: first.context,\n        }),\n      })\n\n      if (encodedPayload) {\n        if (url.includes('?')) {\n          url += `&${encodedPayload}`\n        } else {\n          url += `?${encodedPayload}`\n        }\n      }\n    }\n\n    const handlerResponse = await handler(url, {\n      method: first.method,\n      headers,\n      ...getFetcherRequestOptions(first),\n    })\n\n    const response = await handleResponseErrors(handlerResponse)\n\n    // Check if the response is JSON\n    if (response.headers.get('content-type')?.includes('application/json')) {\n      // Even though the response is JSON, we need to decode it\n      // because the server may have transformed it\n      const json = startSerializer.decode(await response.json())\n\n      // If the response is a redirect or not found, throw it\n      // for the router to handle\n      if (isRedirect(json) || isNotFound(json) || json instanceof Error) {\n        throw json\n      }\n\n      return json\n    }\n\n    // Must be a raw response\n    return response\n  }\n\n  // If not a custom fetcher, just proxy the arguments\n  // through as a POST request\n  const response = await handleResponseErrors(\n    await handler(url, {\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(args),\n    }),\n  )\n\n  // If the response is JSON, return it parsed\n  const contentType = response.headers.get('content-type')\n  if (contentType && contentType.includes('application/json')) {\n    return startSerializer.decode(await response.json())\n  } else {\n    // Otherwise, return the text as a fallback\n    // If the user wants more than this, they can pass a\n    // request instead\n    return response.text()\n  }\n}\n\nfunction getFetcherRequestOptions(opts: MiddlewareOptions) {\n  if (opts.method === 'POST') {\n    if (opts.data instanceof FormData) {\n      opts.data.set('__TSR_CONTEXT', startSerializer.stringify(opts.context))\n      return {\n        body: opts.data,\n      }\n    }\n\n    return {\n      body: startSerializer.stringify({\n        data: opts.data ?? null,\n        context: opts.context,\n      }),\n    }\n  }\n\n  return {}\n}\n\nasync function handleResponseErrors(response: Response) {\n  if (!response.ok) {\n    const contentType = response.headers.get('content-type')\n    const isJson = contentType && contentType.includes('application/json')\n\n    if (isJson) {\n      throw startSerializer.decode(await response.json())\n    }\n\n    throw new Error(await response.text())\n  }\n\n  return response\n}\n"],
  "mappings": "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",
  "names": ["preloadMeta", "assetScripts", "_a", "_a", "_c", "_b", "response", "json"]
}
