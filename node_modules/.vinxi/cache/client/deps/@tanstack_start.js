import {
  RouterProvider,
  encode,
  invariant,
  isNotFound,
  isPlainObject,
  isRedirect,
  tiny_warning_esm_default,
  useRouter,
  useRouterState
} from "./chunk-VZNBQOQN.js";
import {
  require_jsx_runtime
} from "./chunk-EIBOKKOB.js";
import "./chunk-FZOHFCUW.js";
import {
  require_react
} from "./chunk-E27JS66G.js";
import {
  __toESM
} from "./chunk-4MBMRILA.js";

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/Asset.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function Asset({ tag, attrs, children }) {
  switch (tag) {
    case "title":
      return (0, import_jsx_runtime.jsx)("title", { ...attrs, suppressHydrationWarning: true, children });
    case "meta":
      return (0, import_jsx_runtime.jsx)("meta", { ...attrs, suppressHydrationWarning: true });
    case "link":
      return (0, import_jsx_runtime.jsx)("link", { ...attrs, suppressHydrationWarning: true });
    case "style":
      return (0, import_jsx_runtime.jsx)(
        "style",
        {
          ...attrs,
          dangerouslySetInnerHTML: { __html: children }
        }
      );
    case "script":
      if (attrs && attrs.src) {
        return (0, import_jsx_runtime.jsx)("script", { ...attrs, suppressHydrationWarning: true });
      }
      if (typeof children === "string")
        return (0, import_jsx_runtime.jsx)(
          "script",
          {
            ...attrs,
            dangerouslySetInnerHTML: {
              __html: children
            },
            suppressHydrationWarning: true
          }
        );
      return null;
    default:
      return null;
  }
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/createIsomorphicFn.js
function createIsomorphicFn() {
  return null;
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/headers.js
function toHeadersInstance(init) {
  if (init instanceof Headers) {
    return new Headers(init);
  } else if (Array.isArray(init)) {
    return new Headers(init);
  } else if (typeof init === "object") {
    return new Headers(init);
  } else {
    return new Headers();
  }
}
function mergeHeaders(...headers) {
  return headers.reduce((acc, header) => {
    const headersInstance = toHeadersInstance(header);
    for (const [key, value] of headersInstance.entries()) {
      acc.set(key, value);
    }
    return acc;
  }, new Headers());
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/registerGlobalMiddleware.js
var globalMiddleware = [];
function registerGlobalMiddleware(options) {
  globalMiddleware.push(...options.middleware);
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/serializer.js
var startSerializer = {
  stringify: (value) => JSON.stringify(value, function replacer(key, val) {
    const ogVal = this[key];
    const serializer = serializers.find((t) => t.stringifyCondition(ogVal));
    if (serializer) {
      return serializer.stringify(ogVal);
    }
    return val;
  }),
  parse: (value) => JSON.parse(value, function parser(key, val) {
    const ogVal = this[key];
    if (isPlainObject(ogVal)) {
      const serializer = serializers.find((t) => t.parseCondition(ogVal));
      if (serializer) {
        return serializer.parse(ogVal);
      }
    }
    return val;
  }),
  encode: (value) => {
    if (Array.isArray(value)) {
      return value.map((v) => startSerializer.encode(v));
    }
    if (isPlainObject(value)) {
      return Object.fromEntries(
        Object.entries(value).map(([key, v]) => [
          key,
          startSerializer.encode(v)
        ])
      );
    }
    const serializer = serializers.find((t) => t.stringifyCondition(value));
    if (serializer) {
      return serializer.stringify(value);
    }
    return value;
  },
  decode: (value) => {
    if (isPlainObject(value)) {
      const serializer = serializers.find((t) => t.parseCondition(value));
      if (serializer) {
        return serializer.parse(value);
      }
    }
    if (Array.isArray(value)) {
      return value.map((v) => startSerializer.decode(v));
    }
    if (isPlainObject(value)) {
      return Object.fromEntries(
        Object.entries(value).map(([key, v]) => [
          key,
          startSerializer.decode(v)
        ])
      );
    }
    return value;
  }
};
var createSerializer = (key, check, toValue, fromValue) => ({
  key,
  stringifyCondition: check,
  stringify: (value) => ({ [`$${key}`]: toValue(value) }),
  parseCondition: (value) => Object.hasOwn(value, `$${key}`),
  parse: (value) => fromValue(value[`$${key}`])
});
var serializers = [
  createSerializer(
    // Key
    "undefined",
    // Check
    (v) => v === void 0,
    // To
    () => 0,
    // From
    () => void 0
  ),
  createSerializer(
    // Key
    "date",
    // Check
    (v) => v instanceof Date,
    // To
    (v) => v.toISOString(),
    // From
    (v) => new Date(v)
  ),
  createSerializer(
    // Key
    "error",
    // Check
    (v) => v instanceof Error,
    // To
    (v) => ({
      ...v,
      message: v.message,
      stack: true ? v.stack : void 0,
      cause: v.cause
    }),
    // From
    (v) => Object.assign(new Error(v.message), v)
  ),
  createSerializer(
    // Key
    "formData",
    // Check
    (v) => v instanceof FormData,
    // To
    (v) => {
      const entries = {};
      v.forEach((value, key) => {
        const entry = entries[key];
        if (entry !== void 0) {
          if (Array.isArray(entry)) {
            entry.push(value);
          } else {
            entries[key] = [entry, value];
          }
        } else {
          entries[key] = value;
        }
      });
      return entries;
    },
    // From
    (v) => {
      const formData = new FormData();
      Object.entries(v).forEach(([key, value]) => {
        if (Array.isArray(value)) {
          value.forEach((val) => formData.append(key, val));
        } else {
          formData.append(key, value);
        }
      });
      return formData;
    }
  )
];

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/createServerFn.js
function createServerFn(options, __opts) {
  const resolvedOptions = __opts || options || {};
  if (typeof resolvedOptions.method === "undefined") {
    resolvedOptions.method = "GET";
  }
  return {
    options: resolvedOptions,
    middleware: (middleware) => {
      return createServerFn(
        void 0,
        Object.assign(resolvedOptions, { middleware })
      );
    },
    validator: (validator) => {
      return createServerFn(
        void 0,
        Object.assign(resolvedOptions, { validator })
      );
    },
    handler: (...args) => {
      const [extractedFn, serverFn] = args;
      Object.assign(resolvedOptions, {
        ...extractedFn,
        extractedFn,
        serverFn
      });
      if (!extractedFn.url) {
        console.warn(extractedFn);
        tiny_warning_esm_default(
          false,
          `createServerFn must be called with a function that has a 'url' property. Ensure that the @tanstack/start-plugin is ordered **before** the @tanstack/server-functions-plugin.`
        );
      }
      const resolvedMiddleware = [
        ...resolvedOptions.middleware || [],
        serverFnBaseToMiddleware(resolvedOptions)
      ];
      return Object.assign(
        async (opts) => {
          return executeMiddleware(resolvedMiddleware, "client", {
            ...extractedFn,
            method: resolvedOptions.method,
            data: opts == null ? void 0 : opts.data,
            headers: opts == null ? void 0 : opts.headers,
            context: {}
          }).then((d) => {
            if (d.error) throw d.error;
            return d.result;
          });
        },
        {
          // This copies over the URL, function ID and filename
          ...extractedFn,
          // The extracted function on the server-side calls
          // this function
          __executeServer: async (opts) => {
            const parsedOpts = opts instanceof FormData ? extractFormDataContext(opts) : opts;
            const result = await executeMiddleware(
              resolvedMiddleware,
              "server",
              {
                ...extractedFn,
                ...parsedOpts
              }
            ).then((d) => ({
              // Only send the result and sendContext back to the client
              result: d.result,
              error: d.error,
              context: d.sendContext
            }));
            return result;
          }
        }
      );
    }
  };
}
function extractFormDataContext(formData) {
  const serializedContext = formData.get("__TSR_CONTEXT");
  formData.delete("__TSR_CONTEXT");
  if (typeof serializedContext !== "string") {
    return {
      context: {},
      data: formData
    };
  }
  try {
    const context = startSerializer.parse(serializedContext);
    return {
      context,
      data: formData
    };
  } catch {
    return {
      data: formData
    };
  }
}
function flattenMiddlewares(middlewares) {
  const seen = /* @__PURE__ */ new Set();
  const flattened = [];
  const recurse = (middleware) => {
    middleware.forEach((m) => {
      if (m.options.middleware) {
        recurse(m.options.middleware);
      }
      if (!seen.has(m)) {
        seen.add(m);
        flattened.push(m);
      }
    });
  };
  recurse(middlewares);
  return flattened;
}
var applyMiddleware = async (middlewareFn, ctx, nextFn) => {
  return middlewareFn({
    ...ctx,
    next: async (userCtx = {}) => {
      return nextFn({
        ...ctx,
        ...userCtx,
        context: {
          ...ctx.context,
          ...userCtx.context
        },
        sendContext: {
          ...ctx.sendContext,
          ...userCtx.sendContext ?? {}
        },
        headers: mergeHeaders(ctx.headers, userCtx.headers),
        result: userCtx.result !== void 0 ? userCtx.result : ctx.result,
        error: userCtx.error ?? ctx.error
      });
    }
  });
};
function execValidator(validator, input) {
  if (validator == null) return {};
  if ("~standard" in validator) {
    const result = validator["~standard"].validate(input);
    if (result instanceof Promise)
      throw new Error("Async validation not supported");
    if (result.issues)
      throw new Error(JSON.stringify(result.issues, void 0, 2));
    return result.value;
  }
  if ("parse" in validator) {
    return validator.parse(input);
  }
  if (typeof validator === "function") {
    return validator(input);
  }
  throw new Error("Invalid validator type!");
}
async function executeMiddleware(middlewares, env, opts) {
  const flattenedMiddlewares = flattenMiddlewares([
    ...globalMiddleware,
    ...middlewares
  ]);
  const next = async (ctx) => {
    const nextMiddleware = flattenedMiddlewares.shift();
    if (!nextMiddleware) {
      return ctx;
    }
    if (nextMiddleware.options.validator && (env === "client" ? nextMiddleware.options.validateClient : true)) {
      ctx.data = await execValidator(nextMiddleware.options.validator, ctx.data);
    }
    const middlewareFn = env === "client" ? nextMiddleware.options.client : nextMiddleware.options.server;
    if (middlewareFn) {
      return applyMiddleware(middlewareFn, ctx, async (newCtx) => {
        const clientAfter = nextMiddleware.options.clientAfter;
        if (env === "client" && clientAfter) {
          const result = await next(newCtx);
          return applyMiddleware(
            clientAfter,
            {
              ...newCtx,
              ...result
            },
            // Identity, because there "next" is just returning
            (d) => d
          );
        }
        return next(newCtx).catch((error) => {
          if (isRedirect(error) || isNotFound(error)) {
            return {
              ...newCtx,
              error
            };
          }
          throw error;
        });
      });
    }
    return next(ctx);
  };
  return next({
    ...opts,
    headers: opts.headers || {},
    sendContext: opts.sendContext || {},
    context: opts.context || {}
  });
}
function serverFnBaseToMiddleware(options) {
  return {
    _types: void 0,
    options: {
      validator: options.validator,
      validateClient: options.validateClient,
      client: async ({ next, sendContext, ...ctx }) => {
        var _a;
        const serverCtx = await ((_a = options.extractedFn) == null ? void 0 : _a.call(options, {
          ...ctx,
          // switch the sendContext over to context
          context: sendContext
        }));
        return next(serverCtx);
      },
      server: async ({ next, ...ctx }) => {
        var _a;
        const result = await ((_a = options.serverFn) == null ? void 0 : _a.call(options, ctx));
        return next({
          ...ctx,
          result
        });
      }
    }
  };
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/createMiddleware.js
function createMiddleware(options, __opts) {
  const resolvedOptions = __opts || (options || {});
  return {
    options: resolvedOptions,
    middleware: (middleware) => {
      return createMiddleware(
        void 0,
        Object.assign(resolvedOptions, { middleware })
      );
    },
    validator: (validator) => {
      return createMiddleware(
        void 0,
        Object.assign(resolvedOptions, { validator })
      );
    },
    client: (client) => {
      return createMiddleware(
        void 0,
        Object.assign(resolvedOptions, { client })
      );
    },
    server: (server) => {
      return createMiddleware(
        void 0,
        Object.assign(resolvedOptions, { server })
      );
    },
    clientAfter: (clientAfter) => {
      return createMiddleware(
        void 0,
        Object.assign(resolvedOptions, { clientAfter })
      );
    }
  };
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/envOnly.js
var serverOnly = (fn) => fn;
var clientOnly = (fn) => fn;

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/json.js
function json(payload, init) {
  return new Response(JSON.stringify(payload), {
    ...init,
    headers: mergeHeaders(
      { "content-type": "application/json" },
      init == null ? void 0 : init.headers
    )
  });
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/Meta.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var useMeta = () => {
  const router = useRouter();
  const routeMeta = useRouterState({
    select: (state) => {
      return state.matches.map((match) => match.meta).filter(Boolean);
    }
  });
  const meta = React.useMemo(() => {
    const resultMeta = [];
    const metaByAttribute = {};
    let title;
    [...routeMeta].reverse().forEach((metas) => {
      [...metas].reverse().forEach((m) => {
        if (!m) return;
        if (m.title) {
          if (!title) {
            title = {
              tag: "title",
              children: m.title
            };
          }
        } else {
          const attribute = m.name ?? m.property;
          if (attribute) {
            if (metaByAttribute[attribute]) {
              return;
            } else {
              metaByAttribute[attribute] = true;
            }
          }
          resultMeta.push({
            tag: "meta",
            attrs: {
              ...m
            }
          });
        }
      });
    });
    if (title) {
      resultMeta.push(title);
    }
    resultMeta.reverse();
    return resultMeta;
  }, [routeMeta]);
  const links = useRouterState({
    select: (state) => state.matches.map((match) => match.links).filter(Boolean).flat(1).map((link) => ({
      tag: "link",
      attrs: {
        ...link
      }
    })),
    structuralSharing: true
  });
  const preloadMeta = useRouterState({
    select: (state) => {
      const preloadMeta2 = [];
      state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach(
        (route) => {
          var _a, _b, _c, _d;
          return (_d = (_c = (_b = (_a = router.ssr) == null ? void 0 : _a.manifest) == null ? void 0 : _b.routes[route.id]) == null ? void 0 : _c.preloads) == null ? void 0 : _d.filter(Boolean).forEach((preload) => {
            preloadMeta2.push({
              tag: "link",
              attrs: {
                rel: "modulepreload",
                href: preload
              }
            });
          });
        }
      );
      return preloadMeta2;
    },
    structuralSharing: true
  });
  return uniqBy(
    [...meta, ...preloadMeta, ...links],
    (d) => {
      return JSON.stringify(d);
    }
  );
};
var useMetaElements = () => {
  const meta = useMeta();
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: meta.map((asset) => (0, import_react.createElement)(Asset, { ...asset, key: `tsr-meta-${JSON.stringify(asset)}` })) });
};
var Meta = () => {
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: useMetaElements() });
};
function uniqBy(arr, fn) {
  const seen = /* @__PURE__ */ new Set();
  return arr.filter((item) => {
    const key = fn(item);
    if (seen.has(key)) {
      return false;
    }
    seen.add(key);
    return true;
  });
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/Scripts.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
var Scripts = () => {
  const router = useRouter();
  const assetScripts = useRouterState({
    select: (state) => {
      var _a;
      const assetScripts2 = [];
      const manifest = (_a = router.ssr) == null ? void 0 : _a.manifest;
      if (!manifest) {
        tiny_warning_esm_default(false, "<Scripts /> found no manifest");
        return [];
      }
      state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach(
        (route) => {
          var _a2, _b;
          return (_b = (_a2 = manifest.routes[route.id]) == null ? void 0 : _a2.assets) == null ? void 0 : _b.filter((d) => d.tag === "script").forEach((asset) => {
            assetScripts2.push({
              tag: "script",
              attrs: asset.attrs,
              children: asset.children
            });
          });
        }
      );
      return assetScripts2;
    },
    structuralSharing: true
  });
  const { scripts } = useRouterState({
    select: (state) => ({
      scripts: state.matches.map((match) => match.scripts).flat(1).filter(Boolean).map(({ children, ...script }) => ({
        tag: "script",
        attrs: {
          ...script,
          suppressHydrationWarning: true
        },
        children
      }))
    })
  });
  const allScripts = [...scripts, ...assetScripts];
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: allScripts.map((asset, i) => (
    // eslint-disable-next-line @eslint-react/no-array-index-key
    (0, import_react2.createElement)(Asset, { ...asset, key: `tsr-scripts-${asset.tag}-${i}` })
  )) });
};

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/StartClient.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/ssr-client.js
function hydrate(router) {
  var _a, _b, _c;
  invariant(
    (_a = window.__TSR_SSR__) == null ? void 0 : _a.dehydrated,
    "Expected to find a dehydrated data on window.__TSR_SSR__.dehydrated... but we did not. Please file an issue!"
  );
  const { manifest, dehydratedData } = startSerializer.parse(
    window.__TSR_SSR__.dehydrated
  );
  router.ssr = {
    manifest,
    serializer: startSerializer
  };
  router.clientSsr = {
    getStreamedValue: (key) => {
      var _a2;
      if (router.isServer) {
        return void 0;
      }
      const streamedValue = (_a2 = window.__TSR_SSR__) == null ? void 0 : _a2.streamedValues[key];
      if (!streamedValue) {
        return;
      }
      if (!streamedValue.parsed) {
        streamedValue.parsed = router.ssr.serializer.parse(streamedValue.value);
      }
      return streamedValue.parsed;
    }
  };
  const matches = router.matchRoutes(router.state.location).map((match) => {
    var _a2, _b2, _c2;
    const route = router.looseRoutesById[match.routeId];
    const dehydratedMatch = window.__TSR_SSR__.matches.find(
      (d) => d.id === match.id
    );
    if (dehydratedMatch) {
      Object.assign(match, dehydratedMatch);
      const parentMatch = router.state.matches[match.index - 1];
      const parentContext = (parentMatch == null ? void 0 : parentMatch.context) ?? router.options.context ?? {};
      if (dehydratedMatch.__beforeLoadContext) {
        match.__beforeLoadContext = router.ssr.serializer.parse(
          dehydratedMatch.__beforeLoadContext
        );
        match.context = {
          ...parentContext,
          ...match.context,
          ...match.__beforeLoadContext
        };
      }
      if (dehydratedMatch.loaderData) {
        match.loaderData = router.ssr.serializer.parse(
          dehydratedMatch.loaderData
        );
      }
      if (dehydratedMatch.error) {
        match.error = router.ssr.serializer.parse(dehydratedMatch.error);
      }
      (_a2 = match.extracted) == null ? void 0 : _a2.forEach((ex) => {
        deepMutableSetByPath(match, ["loaderData", ...ex.path], ex.value);
      });
    } else {
      Object.assign(match, {
        status: "success",
        updatedAt: Date.now()
      });
    }
    const headFnContent = (_c2 = (_b2 = route.options).head) == null ? void 0 : _c2.call(_b2, {
      matches: router.state.matches,
      match,
      params: match.params,
      loaderData: match.loaderData
    });
    Object.assign(match, {
      meta: headFnContent == null ? void 0 : headFnContent.meta,
      links: headFnContent == null ? void 0 : headFnContent.links,
      scripts: headFnContent == null ? void 0 : headFnContent.scripts
    });
    return match;
  });
  router.__store.setState((s) => {
    return {
      ...s,
      matches
    };
  });
  (_c = (_b = router.options).hydrate) == null ? void 0 : _c.call(_b, dehydratedData);
}
function deepMutableSetByPath(obj, path, value) {
  if (path.length === 1) {
    obj[path[0]] = value;
  }
  const [key, ...rest] = path;
  if (Array.isArray(obj)) {
    deepMutableSetByPath(obj[Number(key)], rest, value);
  } else if (isPlainObject(obj)) {
    deepMutableSetByPath(obj[key], rest, value);
  }
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/StartClient.js
function StartClient(props) {
  if (!props.router.state.matches.length) {
    hydrate(props.router);
  }
  return (0, import_jsx_runtime4.jsx)(RouterProvider, { router: props.router });
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/renderRSC.js
var import_react3 = __toESM(require_react(), 1);
function renderRsc(input) {
  if ((0, import_react3.isValidElement)(input)) {
    return input;
  }
  if (typeof input === "object" && !input.state) {
    input.state = {
      status: "pending",
      promise: Promise.resolve().then(() => {
        invariant(false, "renderRSC() is coming soon!");
      }).then((element) => {
        input.state.value = element;
        input.state.status = "success";
      }).catch((err) => {
        input.state.status = "error";
        input.state.error = err;
      })
    };
  }
  if (input.state.status === "pending") {
    throw input.state.promise;
  }
  return input.state.value;
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/useServerFn.js
function useServerFn(serverFn) {
  const router = useRouter();
  return async (...args) => {
    try {
      const res = await serverFn(...args);
      if (isRedirect(res)) {
        throw res;
      }
      return res;
    } catch (err) {
      if (isRedirect(err)) {
        const resolvedRedirect = router.resolveRedirect({
          ...err,
          _fromLocation: router.state.location
        });
        return router.navigate(resolvedRedirect);
      }
      throw err;
    }
  };
}

// node_modules/.pnpm/@tanstack+start-client@1.99.6_@types+node@22.13.1_db0@0.2.3_drizzle-orm@0.39.2_@types+react@1_v5xsk6dpsdcfybtcj2gjmmwlge/node_modules/@tanstack/start-client/dist/esm/serverFnFetcher.js
async function serverFnFetcher(url, args, handler) {
  var _a;
  const _first = args[0];
  if (isPlainObject(_first) && _first.method) {
    const first = _first;
    const type = first.data instanceof FormData ? "formData" : "payload";
    const headers = new Headers({
      ...type === "payload" ? {
        "content-type": "application/json",
        accept: "application/json"
      } : {},
      ...first.headers instanceof Headers ? Object.fromEntries(first.headers.entries()) : first.headers || {}
    });
    if (first.method === "GET") {
      const encodedPayload = encode({
        payload: startSerializer.stringify({
          data: first.data,
          context: first.context
        })
      });
      if (encodedPayload) {
        if (url.includes("?")) {
          url += `&${encodedPayload}`;
        } else {
          url += `?${encodedPayload}`;
        }
      }
    }
    const handlerResponse = await handler(url, {
      method: first.method,
      headers,
      ...getFetcherRequestOptions(first)
    });
    const response2 = await handleResponseErrors(handlerResponse);
    if ((_a = response2.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
      const json2 = startSerializer.decode(await response2.json());
      if (isRedirect(json2) || isNotFound(json2) || json2 instanceof Error) {
        throw json2;
      }
      return json2;
    }
    return response2;
  }
  const response = await handleResponseErrors(
    await handler(url, {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(args)
    })
  );
  const contentType = response.headers.get("content-type");
  if (contentType && contentType.includes("application/json")) {
    return startSerializer.decode(await response.json());
  } else {
    return response.text();
  }
}
function getFetcherRequestOptions(opts) {
  if (opts.method === "POST") {
    if (opts.data instanceof FormData) {
      opts.data.set("__TSR_CONTEXT", startSerializer.stringify(opts.context));
      return {
        body: opts.data
      };
    }
    return {
      body: startSerializer.stringify({
        data: opts.data ?? null,
        context: opts.context
      })
    };
  }
  return {};
}
async function handleResponseErrors(response) {
  if (!response.ok) {
    const contentType = response.headers.get("content-type");
    const isJson = contentType && contentType.includes("application/json");
    if (isJson) {
      throw startSerializer.decode(await response.json());
    }
    throw new Error(await response.text());
  }
  return response;
}
export {
  Asset,
  Meta,
  Scripts,
  StartClient,
  clientOnly,
  createIsomorphicFn,
  createMiddleware,
  createServerFn,
  globalMiddleware,
  json,
  mergeHeaders,
  registerGlobalMiddleware,
  renderRsc,
  serverFnFetcher,
  serverOnly,
  startSerializer,
  useServerFn
};
//# sourceMappingURL=@tanstack_start.js.map
